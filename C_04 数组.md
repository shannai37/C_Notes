数组是一种线性表结构

## 什么是线性表？

1.有序性：元素按顺序排列，第一个、第二个...有明确位置

 2.同质性：所有元素都是相同类型

3.有限性：元素个数是有限的

4.唯一性：除了第一个和最后一个，每个元素都有唯一的前驱和后继

## 数组的特点

1.相同类型：所有元素必须是同一种数据类型

2.连续存储：在内存中排成一排

3.固定大小：定义（声明）时确定长度，运行时不能改变

4.下标访问：通过索引（从0开始）访问元素

5.**数组名是数组的首元素地址**

### 数组长度的计算

数组长度 = 总字节数 ÷ 单个元素字节数

```c
int length = sizeof(array) / sizeof(array[0]);
```

### 关于“定义时确定长度”

从C98标准开始，下面这么写完全合法：

```c
int arr[] = {1, 2, 3, 4, 5};  
// 编译器自动推断为：
// int arr[5] = {1, 2, 3, 4, 5};
```

其他比如字符数组、浮点数组都是这样的

```c
char letters[] = {'a', 'b', 'c', 'd'};  // 自动为char[4]
char str[] = "hello";                    // 自动为char[6]（包含'\0'）
float prices[] = {12.5, 15.8, 9.9};     // 自动为float[3]
double values[] = {3.14, 2.71, 1.41};   // 自动为double[3]
```

**注意！**不能先声明后初始化，也就是我们“定义时确定长度”

```c
int arr[];           // ❌ 错误！必须指定大小或初始化
arr = {1, 2, 3};     // ❌ 错误！不能这样赋值
```

作为函数参数时：

```c
void func(int arr[])  // ✅ 可以，但这里[]不是自动推断，而是指针
{
    // arr在这里实际上是指针，不是数组
}

void func2(int arr[] = {1,2,3})  // ❌ 错误！参数不能有默认值
{
}
```



## 二维数组部分：

### 字符串末尾\0问题：

#### 1.为什么需要\0?

因为C语言的字符串本质上就是字符数组，但C语言需要知道这个字符串在哪里结束。\0就是字符串结束的标志，ASCII码值为0。

#### 2.自动添加\0的情况:

当你用双引号初始化时，比如

```c
char arr[11] = "helloworld";
```

，编译器会自动在末尾加\0。所以实际上存储的是：'h','e','l','l','o','w','o','r','l','d','\0'，总共11个字符。

#### 3.如果数组长度不够会怎么样？

比如

```c
char arr[10] = "helloworld";
```

，这种情况下，10个位置只够放"helloworld"本身（10个字符），没有空间放\0了。这时候：

- 编译器可能会警告你

- 这个数组不是一个合法的字符串

- 如果你用

  ```
  printf("%s", arr)
  ```

  打印，printf会一直往后找\0，直到找到为止，这就会读取到数组外的内存，产生乱码或崩溃

#### 4.Dev-C++为什么不乱码？

 因为它的内存分配可能恰好在你数组后面有个0值，或者编译器做了额外的优化处理。但这不代表你的代码是对的，换个编译器或运行环境就会出问题

### 字符串字面量和指针的问题：

#### 1.字符串字面量是什么？

 `"helloworld"`  这种用双引号括起来的就是字符串字面量。它在编译时就存储在程序的只读数据区，有固定的内存地址。

#### 2.字符串字面量和指针的关系：

比如

```c
char *p = "hello";
```

p是一个指针，指向字符串字面量"hello"的首地址

（换个说法，p 是一个指针，存储的值是首字符 'h' 的地址）。

```c
char *p = "hello";

printf("%p\n", p);          // 打印p的值（首字符的地址）
printf("%p\n", &p[0]);      // 打印'h'的地址（和上面一样）
printf("%c\n", *p);         // 输出 h（访问首字符）
printf("%c\n", p[0]);       // 也是输出 h

printf("%p\n", &p);         // 这个是打印指针变量p本身的地址（不同的值）
```



但这不代表字符串字面量"本质就是指针"，而是说**字符串字面量 在表达式中会退化为 指向其首字符的指针**。

#### 3.数组初始化？

```c
char arr[11] = "helloworld";
```

这种写法是 **数组初始化**，不是指针赋值。

这里发生的是内容拷贝，把字符串字面量的内容（包括\0）复制到arr数组里。

#### 4.什么时候用指针数组存储多个字符串？什么时候用二维数组？

```c
   char *arr[] = {"hello", "world", "test"};  // 指针数组
```

这种方式的特点是：

- 每个字符串长度可以不同

- 字符串存在只读区，不能修改

- 节省内存（不同字符串不需要统一长度）



```c
   char arr[][10] = {"hello", "world", "test"};  // 二维数组
```

这种方式的特点是：

- 每个字符串占用的空间是固定的（这里是10）

- 短字符串会浪费空间（"hi"也要占10个位置）

- 但内容可以修改

- 内存是连续的一大块



#### 5.指针数组补充

我们上面说：字符串字面量在表达式中会退化为指向其首字符的指针

//先简单补充一下,首字符是什么？中文还适用吗：

```c
char *arr[] = {"hello", "world", "test"};
```

arr[0] 是一个 char *，指向 "hello" 的第一个字符 'h'
arr[1]、arr[2]同理

数组名 arr 在大多数情况下会退化为指向首元素的指针

首元素是arr[0]，arr[0] 的地址就是 &arr[0]，**arr 实际上是 &arr[0]，也就是指向第一个指针的地址**

//"石头" 在内存中是什么样？假设是UTF-8编码（一个中文字符通常占 3个字节）：

```c
char *choices[3] = {"石头", "剪刀", "布"};
```

```
"石头" = [石的字节1][石的字节2][石的字节3][头的字节1][头的字节2][头的字节3][\0]
总共7个字节（6个字节表示两个汉字 + 1个\0）
```

**变成中文后**，"退化为指向其首字符的指针" 依然成立，但是**这里的"字符"指的是首字节，并不是单个汉字**。

choices[0] 这个指针依然是指向字符串的首字节，也就是"石"字的第一个字节  

#### 总结：

- 单个字符串用char arr[]就行

- 多个字符串，如果只读且长度不一，用char *arr[]指针数组

- 多个字符串，如果需要修改内容，用char arr[][长度]二维数组



#### 能否用char类型存单个符号？

上面说了，多个字符串，且要修改，我们用char arr二维数组

假设我现在要打印一个20行20列的□，其中的有些部分要用★▲■其他符号代替。

```c
int i , j;
	for(i = 0 ; i < 20 ; i++)
	{
		for(j = 0 ; j < 20 ; j++)
		{
            map[i][j] = "□"; 
		}
	}
	
	for(i = 0 ; i < 20 ; i++)
	{
		for(j = 0 ; j < 20 ; j++)
		{
			printf("%s",map[i][j]);
		}
		printf("\n");
	}
```

可以这样不？

答案是否定的。哪怕你换成%c，也打不出想要的□。

1. **char 类型只能存储 1 个字节**：

- `char map [20][20]` 中每个元素只能存储一个字节

- 中文字符 "□" 在中文编码（GBK/UTF-8）中占用 2-3 个字节

2.

- "□" 是字符串（const char*指针）

- `map[i][j] `是单个 char

- 不能把字符串赋值给单个字符

所以我们只能直接打印，或者三维数组

```c
char map[20][20][4];  // 每个格子存储一个字符串（最多3字节+结尾\0）

void Game()
{
    int i, j;
    for(i = 0; i < 20; i++)
    {
        for(j = 0; j < 20; j++)
        {
            strcpy(map[i][j], "□");  // 使用 strcpy 复制字符串
        }
    }
    
    for(i = 0; i < 20; i++)
    {
        for(j = 0; j < 20; j++)
        {
            printf("%s", map[i][j]);  // 使用 %s 打印字符串
        }
        printf("\n");
    }
}
```

