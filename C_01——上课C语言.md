## 第一章——计算机组成原理

1964-1971 中小规模集成电路 电脑开始走进千家万户

1970年 计算机元年 时间计算都是从这开始

![image-20250920104044802](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250920104044802.png)



早期冯诺依曼机结构

以运算器为核心

![image-20250920110037426](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250920110037426.png)



![image-20250920110120253](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250920110120253.png)

现代计算机结构

以存储器为中心
cpu = 存储器+运算器

![image-20250920110229946](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250920110229946.png)



![image-20250920110411475](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250920110411475.png)



### 1.现代计算机存储结构：

CPU  内存条  磁盘

**CPU**

CPU插槽四周有缺口的，其中有个缺口有个小点（防呆设计），要对应插下去

CPU不支持热插拔

![image-20250920110708078](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250920110708078.png)

**内存条**

一般正常台式电脑主板上四个插口，按13  24插入 双通道激活

笔记本大多数是两个插口

![image-20250920111132423](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250920111132423.png)

**硬盘**

图中机械硬盘大圈中是一圈圈小圈，一个小圈代表一个盘符（C盘、D盘等）

读写速度 盘的转速  转速越高，读写速度越快

![image-20250920111712610](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250920111712610.png)



**固态硬盘**

通过 稀有金属涂层通电断电 电子移动 来读写数据

读写频率过多 金属疲劳  数据会丢失

大多数云盘（如百度网盘），使用的是机械硬盘



### 2.计算机存储（读写由快到慢）

1.CPU寄存器：存放二进制指令，采用位运算，调度所有的硬件 

2.**内存（也叫RAM，主存）**

随机存取存储器（random access memory）

（大多数（90%）软件运行、编译、执行都在内存中操作），GB为单位

内存断电会清空数据

3.磁盘（也叫硬盘，现在也算主存之一）：存储文件，持久化存储

磁盘断电不会清空数据

现在的辅存指的是u盘这种，便携式的

### 3.ROM与电脑硬盘

ROM是只读存储器（Read-Only Memory），

后面出现了EPROM和EEPROM，这两种可擦写

然后又发展出了NAND FLASH闪存，也就是我们U盘用到的技术

ROM和硬盘都可以存储数据而且断电不会丢失，但是严格说两者不是一个东西

磁盘和ROM没什么关系，但是固态硬盘就不一样了，固态硬盘用到的颗粒也是**基于NAND FLASH技术**，和u盘以及手机存储有点相似 ，固态硬盘的存储颗粒是ROM技术发展的产物，关系点在这，但方便记忆的话都会说磁盘就是ROM



### 4.计算机如何知道我们敲的字符或数字？

计算机主板上拷贝了ASCII表，就相当于一个字典，按键给计算机传递二进制数据，计算机接收到这个数据，通过ASCII表查到按键对应的字符



针对不同国家的文字，ASCII码表不够用了，所以在ASCII码表基础上又出现编码字符集

GBK：（国标码，中华人民共和国国家标准）两个部分表示一个中文

UTF-8：跨平台通用字符码，三个部分表示一个中文

不能直接互相转换，会出现乱码情况



### 5.计算机又是如何得知我们敲出来的编程代码是什么意思呢？

语言标准库，一般标准库都在安装的编译工具文件夹下（windows开发）



### 6.进制转换

#### 6.1 ！！！总结

##### 6.1.1 十进制整数转其他进制

- **直接方法（除基取余法）**：对于十进制整数转换，通常使用除基取余法。例如：
  - 转二进制：不断除以2，记录余数，直到商为0，余数从下往上读。
  - 转八进制：不断除以8，记录余数。
  - 转十六进制：不断除以16，记录余数
- **通过二进制中转**：由于二进制与八进制、十六进制有直接对应关系，实践中常先转二进制再转其他：
  - 十进制 → 二进制 → 八进制：将二进制数从小数点开始，向左和向右每3位一组（不足补零），每组转换为一位八进制数。
  - 十进制 → 二进制 → 十六进制：类似，每4位二进制转换为一位十六进制数。

##### 6.1.2 十进制小数转其他进制

- **直接方法（乘基取整法）**：对于小数部分，使用乘基取整法：
  - 转二进制：不断乘以2，取整数部分（0或1），直到小数部分为0或达到所需精度。
  - 转八进制：不断乘以8，取整数部分。
  - 转十六进制：不断乘以16，取整数部分。



##### 6.1.3 其他进制转十进制

- **按权展开求和**：无论整数还是小数，都按权展开求和。例如：

  ![image-20250921161202087](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250921161202087.png)

##### 6.1.4 二进制与八进制、十六进制互转

- **二进制转八进制**：每3位二进制对应一位八进制（从小数点开始分组，不足补零）。例如：二进制111010.011分组为111|010|.011，转八进制为72.3。
- **八进制转二进制**：每位八进制展开为3位二进制。例如：八进制53.2转二进制为101011.010。
- **二进制转十六进制**：每4位二进制对应一位十六进制。例如：二进制11011011.1010分组为1101|1011|.1010，转十六进制为DB.A。
- **十六进制转二进制**：每位十六进制展开为4位二进制。例如：十六进制E.7转二进制为1110.0111。

##### 6.1.5 八进制与十六进制互转

- **通过二进制中转**：这是最方便的方法。例如：
  - 八进制转十六进制：先转二进制（每位八进制变3位二进制），然后二进制转十六进制（每4位分组）。
  - 十六进制转八进制：先转二进制（每位十六进制变4位二进制），然后二进制转八进制（每3位分组）。





**十进制转二进制**

除2取余法

![](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\08bdfad1d2de583a6a163947b690ecd2.png)

**十进制小数转二进制**

![](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\9e9420f25e96d547caddd12aec72df0d.png)



**二进制转十进制**

1.

![image-20250920144213913](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250920144213913.png)

> e.g.
>
> 10111(BIN) = ? (DEC)
>
> 1x2^0 + 1x2^1 + 1x2^2 + 0x2^3 + 1x2^4 = 23
>
> 补充：8位二进制 = 1个字节 = 能表示的十进制范围 0~255   所以ip地址（四个字节，32位二进制组成）最大只有 255.255.255.255

2.

![image-20250920150002101](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250920150002101.png)

**二进制小数转十进制**

![image-20250921153248524](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250921153248524.png)

**二进制转八进制**

每三位二进制  = 八进制 1位数

![image-20250920151139335](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250920151139335.png)

**二进制小数转八进制**

![image-20250921151422576](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250921151422576.png)



**二进制转十六进制**

每四位二进制 = 十六进制1位数

![image-20250920150604915](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250920150604915.png)

**二进制小数转十六进制**



![image-20250921151549947](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250921151549947.png)

#### 6.2 进制转换好题

9.对于不同数制之间关系的描述，正确的描述为_______。
供选择的答案
A:①任意的二进制有限小数，必定也是十进制有限小数。
②任意的八进制有限小数，未必也是二进制有限小数。
③任意的十六进制有限小数，不一定是十进制有限小数。
④任意的十进制有限小数，必然也是八进制有限小数。

- ① 任意的二进制有限小数，必定也是十进制有限小数。
  二进制有限小数对应分母为2的幂的分数，而十进制可以精确表示此类分数，因此该描述正确。

- ② 任意的八进制有限小数，未必也是二进制有限小数。
  八进制有限小数对应分母为8的幂的分数（8=2³），**转换为二进制时，每个八进制数字对应3位二进制数字，因此二进制小数也有限**。该描述错误。

- ③ 任意的十六进制有限小数，不一定是十进制有限小数。

  例如0.2（十六进制）是2/16=0.125十进制，有限。0.1（十六进制）=1/16=0.0625，有限。0.3（十六进制）=3/16=0.1875，有限。**十六进制有限小数对应分母为16的幂的分数（16=2⁴），分母只有因子2**，因此十进制表示也有限。该描述错误。

- ④ 任意的十进制有限小数，必然也是八进制有限小数。
  十进制有限小数对应一个分母是10的幂的分数，即分母有质因子2和5。当转换为八进制时，八进制是基数为8的系统，8=2^3，所以八进制有限小数需要分母是2的幂。**但十进制小数分母有因子5，所以当分母有因子5时，在八进制中可能无法有限表示。**因此十进制小数如0.1（十进制）转换为八进制时无限循环，不是有限小数。（计算一下：0.1 * 8 = 0.8，整数部分0，然后0.8*8=6.4，整数部分6，0.4*8=3.2，整数部分3，0.2*8=1.6，整数部分1，0.6*8=4.8，整数部分4，如此循环，所以八进制是0.063146314...无限循环）该描述错误。



### 7.**比特  与 字节**

8bit  =   1 byte

8位二进制 = 1字节

b  kb=1024b   gb=1024kb  tb  zb            这些存储的b指的是**字节**（我个人更喜欢把字节的B大写）

工业制成按1000来算 ，但计算机中（操作系统）是1024来算

所以就会出现买的U盘、硬盘等，商家跟你说是四GB，实际到电脑上是三点多GB



### ————————————

### 8.C语言基础（一）

float 输出时使用%f 有效数字为小数点后6位,不足6位用0补全，超过6位截断四舍五入

double 输出时使用%lf 有效数字为小数点后17位

`%.2f`表示保留两位小数

`%9f`：保留9位小数



测算类型的最大最小值

测算int、char、long时需要引入头文件`<limits.h>`

测算float和double时需要引入头文件`<float.h>` 格式为`FLT_MIN`和`DBL_MIN`

![image-20250920164908409](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250920164908409.png)



### 9.Dev c++查看内存中的值

[【快速学】Dev C++查看内存中的值 - 尚方咸鱼 - 博客园](https://www.cnblogs.com/FishSmallWorld/p/17074055.html)

### ————————————

### 10.C语言小游戏——扫雷

开出1代表以它为中心，周围的八格内有1个雷

以此类推

![image-20250923185339322](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250923185339322.png)

#### 10.1 游戏规则：

1.玩家视角——网格状地图

地图为两种：

1） 玩家看的地图，地图隐藏

2）逻辑中布置好雷的地图

2.1玩家左键点击情况：

1）踩到雷——游戏结束
2）当前位置周围8格没有雷——继续开辟，打开一片区域

2.2 玩家右键点击： 标旗子

3.玩家胜利情况：

1）标记出所有雷

2）开放所有无雷区域

4.其他隐含条件：

1）雷的位置随机

2）雷和网格随难度的变化而变化



电脑的x、y坐标和我们数学学到的是不一样的

![image-20250923192106309](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250923192106309.png)



运用二维数组表示棋盘，flag去表示雷的状态 

我们二维数组的逻辑就是先行后列

![image-20250923202735262](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250923202735262.png)

#### 10.2 模块化——.c、.h文件：

以test举例：

1）test.c文件要的头文件我们会放在test.h中2）在test.c文件中调用`#include "test.h"`

3)main.c中想要用test.c中的函数时，需要调用`include "test.h"`

“”代表是个人自定义的头文件，如上面提到的`include "test.h"`

<>引入的是C语言函数库的头文件

`include <stdio.h>   `



**好处**：在后期维护时，模块化会使得维护更加方便，并且在修改某个模块时，会十分便捷

#### 10.3 拓展：MVC框架

m：model 数据、业务模型层

v：view 视图层（UI）

c：control 控制层

以画图软件举例：

用户点进去 见到的就是view层，view层上会有一些操作按钮（画笔、工具、形状、配色等），这就是control层，这些操作按钮背后对应的数据或者逻辑操作就是model层



#### 10.4 头文件保护机制



以`test.h`举例：

```C++
#ifndef __TEST_H__     // 如果未定义 __TEST_H__ 这个宏
#define __TEST_H__     // 则定义该宏，并编译下面的代码

// 头文件的实际内容（函数声明、宏定义、结构体等）

#endif                // 结束条件编译
```

作用：

1）防止重复定义错误

2）提高编译效率

- 避免重复编译相同代码
- 减少预处理时间



处理  `当前位置（以A代替）周围8格是否有雷`  逻辑

1.当前位置是雷 -> 游戏结束



2.当前位置不是雷 

1)进入排雷函数，返回周边八格雷的数量，标到A上

​     八个位置没有雷？ -> 继续打开周边八个位置 -> 递归开辟

​	八个位置有雷？ ->  停止

### 11. 使用easyx上实现图形化扫雷

#### 11.1.1 为什么需要双缓冲

- **闪烁问题**：如果不使用双缓冲，当程序逐一出图形时，用户会看到图形一步步绘制的过程，导致视觉上的闪烁。
- **用户体验**：直接在前台缓冲区（屏幕）绘图，用户会看到不完整的中间状态。

#### 11.1.2 双缓冲工作流程

双缓冲机制创建一个"后台缓冲区"，所有绘图操作先在这个不可见的缓冲区进行，完成后再一次性复制到屏幕。

1. **开始批量绘制** (`BeginBatchDraw()`) - 开启双缓冲模式，后续所有绘图操作在后台缓冲区进行。
2. **执行绘制操作** - 在后台缓冲区上绘制所有图形（清屏、画矩形、设置颜色等）。
3. **刷新到屏幕** (`FlushBatchDraw()`) - 将后台缓冲区的内容一次性更新到屏幕上。
4. **结束批量绘制** (`EndBatchDraw()`) - 退出双缓冲模式。
5. 正确的流程：**开始绘制→清屏→绘制图形→刷新显示**

#### 11.1.3 总结

```c
#include <graphics.h>

int main()
{
    initgraph(640, 480);  // 初始化图形窗口
    
    BeginBatchDraw();     // 1. 开始批量绘制（开启双缓冲）
    
    while (!kbhit())      // 主循环（按任意键退出）
    {
        cleardevice();    // 2. 清空后台缓冲区
        
        // 3. 在后台缓冲区上绘制图形
        setlinecolor(RED);
        solidrectangle(100, 100, 200, 200);
        
        FlushBatchDraw(); // 4. 将后台缓冲区内容刷新到屏幕
        Sleep(50);        // 短暂延迟，控制帧率
    }
    
    EndBatchDraw();       // 5. 结束批量绘制
    closegraph();         // 关闭图形窗口
    
    return 0;
}
```

#### 11.2 使用到的EasyX图形库函数

##### 11.2.1 setlinecolor() **- 设置线条颜色**

**功能**：设置后续绘图操作的线条颜色（如矩形边框、直线等）

**语法**：

```c
void setlinecolor(COLORREF color);
```

**参数**：

color：颜色值，通常使用RGB宏定义

- 例如：`RGB(255, 0, 0)` 表示红色
- 也可使用预定义颜色常量：`RED`, `GREEN`, `BLUE`, `BLACK`, `WHITE`等

e.g.

```c
setlinecolor(RGB(255, 0, 0));  // 设置线条为红色
rectangle(100, 100, 200, 200); // 绘制红色边框矩形

setlinecolor(BLUE);            // 设置线条为蓝色
line(50, 50, 150, 150);       // 绘制蓝色直线
```

##### **11.2.2 solidrectangle() - 绘制实心矩形**

**功能**：绘制一个填充的实心矩形

**语法**：

```C
void solidrectangle(int left, int top, int right, int bottom);
```

**参数**：

- `left`：矩形左上角x坐标
- `top`：矩形左上角y坐标
- `right`：矩形右下角x坐标
- `bottom`：矩形右下角y坐标

e.g.

```C
setfillcolor(GREEN);           // 设置填充颜色为绿色
solidrectangle(100, 100, 300, 200); // 绘制绿色实心矩形
```

**与rectangle()的区别**：

- `rectangle()`：只绘制矩形边框
- `solidrectangle()`：绘制填充的实心矩形

**注意事项**：

- 填充颜色由`setfillcolor()`设置
- 边框颜色由`setlinecolor()`设置
- 坐标系统：原点(0,0)在左上角，x向右增加，y向下增加

##### **11.2.3. cleardevice() - 清除屏幕**

**功能**：用当前背景色清除整个屏幕

```C
void cleardevice();
```

e.g.

```c
setbkcolor(WHITE);  // 设置背景色为白色
cleardevice();      // 清除屏幕为白色
```

**注意事项**：

- 清除后整个屏幕变为当前背景色
- 背景色通过`setbkcolor()`设置
- 通常在程序开始或需要重绘时调用
- 会清除所有已绘制的内容

##### **11.2.4. BeginBatchDraw() - 开始批量绘制**

**功能**：开始批量绘制模式，提高绘图效率

```C
void BeginBatchDraw();
```

**作用**：

- 减少屏幕刷新次数，避免闪烁
- 将多个绘图操作合并为一次显示

##### **11.2.5. EndBatchDraw() - 结束批量绘制**

**功能**：结束批量绘制模式

```C
void EndBatchDraw();
```

##### **11.2.6. FlushBatchDraw() - 刷新批量绘制**

**功能**：将批量绘制的内容刷新到屏幕上

```c
void FlushBatchDraw();
```

```c
// 动画示例
for(int i = 0; i < 100; i++)
{
    BeginBatchDraw();
    cleardevice();
    solidrectangle(i, 100, i+50, 150); // 移动的矩形
    FlushBatchDraw(); // 立即显示
    Sleep(50); // 延时
    EndBatchDraw();
}
```



##### **11.2.7. outtextxy() - 在指定位置输出文本**

**功能**：在指定坐标位置输出文本

```c
void outtextxy(int x, int y, LPCTSTR str);
```

**参数**：

- `x`：文本输出的x坐标
- `y`：文本输出的y坐标
- `str`：要输出的文本字符串

e.g.

```C
settextcolor(BLACK);     // 设置文本颜色
setbkmode(TRANSPARENT);  // 设置文本背景透明
outtextxy(100, 100, "Hello World"); // 在(100,100)位置输出文本
```

**注意事项**：

- 默认文本颜色为白色
- 默认背景不透明（通常需要设置为透明）
- 支持中英文输出
- 坐标是文本的左上角位置



outtextxy（）；传参里面是字符串，所以单个字符要转成字符串才能往上填

![image-20250927120309519](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250927120309519.png)



GetMouseClick（）理解逻辑







### 11.3 鼠标操作函数

#### 11.3.1 `MouseHit()`

- **功能**：检查是否有鼠标事件发生
- **返回值**：有鼠标事件返回真(非0)，否则返回假(0)
- **特点**：非阻塞函数，不会让程序等待



#### 11.3.2 `GetMouseMsg()`

- **功能**：获取鼠标消息
- **返回值**：返回`MOUSEMSG`结构体，包含鼠标的详细信息



##### `MOUSEMSG`结构体

通常包含以下字段：

```C
struct MOUSEMSG {
    UINT uMsg;      // 鼠标消息类型
    int x;          // 鼠标x坐标
    int y;          // 鼠标y坐标
    // 其他可能字段...
};
```

##### 鼠标消息常量

- `WM_LBUTTONDOWN`：左键按下
- `WM_RBUTTONDOWN`：右键按下
- `WM_MOUSEMOVE`：鼠标移动
- 等等...
