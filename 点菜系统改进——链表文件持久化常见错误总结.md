# 链表文件持久化常见错误总结

## 项目背景
在实现点菜系统的链表数据持久化功能时，遇到的三个关键错误及解决方案。

---

## 错误一：fwrite 写入长度错误

### 错误代码（document.c 第89行）
```c
void saveUserList(LIST * head)
{
    FILE *fp = fopen("./data/user1.txt","w+");
    LIST * temp = head -> pnext;
    
    char buf[100] = {0};
    while (temp != NULL)
    {
        USER *user = (USER *)(temp -> data);
        sprintf(buf,"%s %s %d\n", 
            user->account,
            user->password,
            user->role
        );
        
        // 错误：使用了 strlen(user)
        fwrite(buf, 1, strlen(user), fp);  // 第89行
        temp = temp -> pnext;
    }
    fclose(fp);
}
```

### 问题分析
1. `user` 是 `USER*` 类型的指针，不是字符串
2. `strlen(user)` 尝试将指针地址当作字符串来计算长度
3. 导致未定义行为，可能返回一个随机的很小的数值
4. 每次只写入少量字节，数据不完整

### 实际后果
文件内容变成：
```
adminmanagerwaiter
```
所有数据挤在一起，没有空格和换行符。

### 正确代码
```c
fwrite(buf, 1, strlen(buf), fp);  // 应该计算 buf 的长度
```

### 知识点
`strlen()` 的参数必须是 `char*` 类型的字符串指针，不能是其他类型的指针。

---

## 错误二：fgets 返回值判断错误

### 错误代码（document.c 第113行）
```c
LIST* getUserList()
{
    FILE *fp = fopen("./data/user1.txt","r+");
    LIST * head = New_List_Init();
    
    char buf[100] = {0};
    // 错误：fgets 返回指针，不能和数字比较
    while ( fgets(buf, sizeof(buf), fp) > 0 )  // 第113行
    {
        USER user;
        sscanf(buf,"%s %s %d",
            user.account,
            user.password,
            &user.role
        );
        New_List_pushback(head, &user, sizeof(user));
    }
    fclose(fp);
    return head;
}
```

### 问题分析
1. `fgets` 函数返回值是指针类型
   - 成功：返回 `buf` 指针
   - 失败：返回 `NULL`
2. 指针不能和数字（`0`）直接用 `>` 比较
3. 虽然有时"碰巧"能工作，但不符合C语言标准

### 正确代码
```c
while ( fgets(buf, sizeof(buf), fp) != NULL )  // 判断是否为 NULL
```

### 知识点
fgets 函数原型：
```c
char *fgets(char *str, int n, FILE *stream);
```
返回值：
- 成功：返回 str 指针
- 到达文件末尾或出错：返回 NULL

---

## 错误三：格式说明符与数据类型不匹配

### 错误代码（document.c 第53行）
```c
LIST* getMenuList()
{
    FILE * fp = fopen("./data/menu1.txt","r+");
    LIST * head = New_List_Init();
    
    char buf[200] = {0};
    while( fgets(buf,sizeof(buf),fp) != NULL )
    {
        MENU menu = {0};
        // 错误：使用 %f 读取 double 类型
        sscanf(buf, "%d %s %f %d",  // 第53行
               &menu.menuID, 
               menu.menuName, 
               &menu.price,      // price 是 double 类型
               &menu.num
        );
        New_List_pushback(head, &menu, sizeof(menu));
    }
    fclose(fp);
    return head;
}
```

### 结构体定义
```c
typedef struct menu
{
    int menuID;
    char menuName[20];
    double price;      // 注意：是 double，不是 float
    int num;    
}MENU;
```

### 问题分析
1. 结构体中 `price` 是 `double` 类型（8字节）
2. `sscanf` 中使用了 `%f`，这是用于 `float` 的格式符（4字节）
3. 导致读取时只写入4字节，剩余4字节是垃圾数据
4. 影响后续数据的读取位置，导致第2、第3条数据读取失败或错乱

### 实际后果
菜单链表只能正确读取第一条数据，后两条数据打印不出来或显示错误。

### 正确代码
```c
sscanf(buf, "%d %s %lf %d",  // double 必须使用 %lf
       &menu.menuID, 
       menu.menuName, 
       &menu.price,
       &menu.num
);
```

### 知识点：格式说明符速查表

| C类型 | printf/sprintf | scanf/sscanf |
|-------|---------------|--------------|
| int | %d | %d |
| float | %f | %f |
| double | %f 或 %lf | **必须 %lf** |
| char[] | %s | %s |
| char | %c | %c |

**关键区别**：
- `printf` 系列函数中，`%f` 和 `%lf` 都可以用于 `double`（因为参数会自动提升）
- `scanf` 系列函数中，`double` **必须**使用 `%lf`，因为需要知道确切的存储大小

---

## 完整的正确实现

### 保存函数示例
```c
void saveUserList(LIST * head)
{
    FILE *fp = fopen("./data/user1.txt","w+");
    if (fp == NULL) {
        printf("文件创建失败\n");
        return;
    }
    
    LIST * temp = head -> pnext;
    char buf[100] = {0};
    
    while (temp != NULL)
    {
        USER *user = (USER *)(temp -> data);
        sprintf(buf, "%s %s %d\n", 
            user->account,
            user->password,
            user->role
        );
        
        fwrite(buf, 1, strlen(buf), fp);  // 正确：strlen(buf)
        temp = temp -> pnext;
    }
    
    fclose(fp);
}
```

### 加载函数示例
```c
LIST* getUserList()
{
    FILE *fp = fopen("./data/user1.txt","r+");
    LIST * head = New_List_Init();
    
    if (fp == NULL) {
        printf("文件不存在\n");
        return head;
    }
    
    char buf[100] = {0};
    while ( fgets(buf, sizeof(buf), fp) != NULL )  // 正确：!= NULL
    {
        USER user;
        sscanf(buf, "%s %s %d",
            user.account,
            user.password,
            &user.role
        );
        New_List_pushback(head, &user, sizeof(user));
    }
    
    fclose(fp);
    return head;
}
```

### 读取double类型示例
```c
LIST* getMenuList()
{
    FILE * fp = fopen("./data/menu1.txt","r+");
    LIST * head = New_List_Init();
    
    if (fp == NULL) {
        printf("文件不存在\n");
        return head;
    }
    
    char buf[200] = {0};
    while( fgets(buf, sizeof(buf), fp) != NULL )
    {
        MENU menu = {0};
        sscanf(buf, "%d %s %lf %d",  // 正确：%lf 用于 double
               &menu.menuID, 
               menu.menuName, 
               &menu.price,
               &menu.num
        );
        New_List_pushback(head, &menu, sizeof(menu));
    }
    
    fclose(fp);
    return head;
}
```

---

## 调试技巧

### 1. 检查文件内容
保存数据后，手动打开文本文件检查格式是否正确：
```
正确格式（user1.txt）：
admin 123456 2
manager 111111 1
waiter 888888 0

错误格式（数据挤在一起）：
adminmanagerwaiter
```

### 2. 添加调试输出
```c
// 在写入时
printf("写入内容: %s", buf);
printf("写入长度: %zu\n", strlen(buf));

// 在读取时
printf("读取内容: %s", buf);
printf("解析结果: %s %s %d\n", user.account, user.password, user.role);
```

### 3. 检查返回值
```c
// 检查文件是否打开成功
if (fp == NULL) {
    printf("文件操作失败\n");
    return;
}

// 检查读取是否成功
size_t count = fwrite(buf, 1, strlen(buf), fp);
printf("实际写入字节数: %zu\n", count);
```

---

## 关键要点总结

1. **strlen 的参数**
   - 必须是字符串（char* 或 char[]）
   - 不能是其他类型的指针

2. **fgets 的返回值**
   - 返回指针类型
   - 成功返回 buf，失败返回 NULL
   - 判断条件：`!= NULL`，而不是 `> 0`

3. **格式说明符匹配**
   - scanf/sscanf 读取 double 必须用 `%lf`
   - printf/sprintf 输出 double 可以用 `%f` 或 `%lf`
   - 类型不匹配会导致内存错误和数据错乱

4. **文件操作流程**
   - 打开文件后检查 fp 是否为 NULL
   - 操作完成后务必 fclose
   - 使用 fgets 按行读取文本文件
   - 使用 sprintf/sscanf 进行格式化转换

---

## 参考资料

### 常用文件操作函数

| 函数 | 用途 | 返回值 |
|------|------|--------|
| fopen | 打开文件 | FILE* (失败返回NULL) |
| fclose | 关闭文件 | 0成功，EOF失败 |
| fgets | 按行读取 | char* (失败返回NULL) |
| fwrite | 写入数据 | 成功写入的元素数 |
| sprintf | 格式化字符串 | 写入的字符数 |
| sscanf | 解析字符串 | 成功解析的项数 |

### 字符串操作函数

| 函数 | 用途 | 注意事项 |
|------|------|---------|
| strlen | 计算字符串长度 | 参数必须是有效字符串 |
| strcpy | 复制字符串 | 确保目标空间足够大 |
| strcmp | 比较字符串 | 返回0表示相等 |
| memset | 清空内存 | 常用于清空缓冲区 |

---

