## 1.什么是指针？

指针就是一个变量，它存储的是另一个变量的内存地址。

想象一下，内存就像一个巨大的公寓楼，每个房间都有一个门牌号（地址），每个房间里可以存放东西（数据）。指针就是记录了某个房间门牌号的纸条。

## 2.基本语法

### 声明指针

```c
int *p;        // p 是一个指向 int 类型的指针
char *cp;      // cp 是一个指向 char 类型的指针
double *dp;    // dp 是一个指向 double 类型的指针
```

### 两个重要运算符

- &（取地址符）：获取变量的内存地址

- *（解引用符）：访问指针指向的内存中的值

## 3.基础示例

```c
#include <stdio.h>

int main() {
    int num = 10;        // 普通变量
    int *p;              // 声明指针
    
    p = &num;            // p 存储 num 的地址
    
    printf("num 的值: %d\n", num);           // 输出: 10
    printf("num 的地址: %p\n", &num);        // 输出地址（如: 0x7ffd1234）
    printf("p 的值（即num的地址）: %p\n", p); // 输出地址
    printf("p 指向的值: %d\n", *p);          // 输出: 10
    
    *p = 20;             // 解引用：修改p指向的值
    printf("修改后 num 的值: %d\n", num);    // 输出: 20
    
    return 0;
}
```

## 4.指针与数组

**数组名本质上就是指向数组第一个元素的指针！**

换句话说，数组名代表了首元素的地址 ，也是指向首元素的指针。

```c
int arr[5] = {10, 20, 30, 40, 50};
int *p = arr;  // 等价于 p = &arr[0]

// 以下几种访问方式等价：
printf("%d\n", arr[0]);    // 数组下标访问
printf("%d\n", *arr);      // 指针解引用
printf("%d\n", *(arr+0));  // 指针算术
printf("%d\n", *p);        // 解引用：读取p指向的值

// 指针算术
printf("%d\n", *(p + 2));  // 访问 arr[2]，输出 30
```

### 指针算术规则：



```c
int arr[5] = {10, 20, 30, 40, 50};
int *p = arr;       // p = 1000 (假设地址为1000)

p = p + 1;          // p = 1004 
                    // 移动了 1个int，即4字节

p = p + 2;          // p = 1012
                    // 又移动了 2个int，即8字节

printf("%d", *p);   // 输出 40 (arr[3])
```

`新地址 = 原地址 + (n × sizeof(数据类型))`

指针相减：

```c
int arr[5] = {10, 20, 30, 40, 50};
int *p1 = &arr[1];
int *p2 = &arr[4];

int distance = p2 - p1;  // 结果是 3（相差3个元素）
                         // 不是字节数！
```

实际运用例子：

```c
int arr[5] = {10, 20, 30, 40, 50};
int *p = arr;

// 方式1：数组下标
for(int i = 0; i < 5; i++) 
{
    printf("%d ", arr[i]);
}

// 方式2：指针算术
for(int i = 0; i < 5; i++) 
{
    printf("%d ", *(p + i));  // p+i 相当于 &arr[i]
}

// 方式3：指针移动
for(int i = 0; i < 5; i++) 
{
    printf("%d ", *p);
    p++;  // 指针移动到下一个元素
}
```



### 二维数组指针

**方式1：普通指针**

```c
int arr[3][4] = {{1,2,3,4}, {5,6,7,8}, {9,10,11,12}};
int *p = &arr[0][0];  // 指向第一个元素

// 遍历所有元素
for(int i = 0; i < 12; i++) {
    printf("%d ", *(p + i));
}
// 输出: 1 2 3 4 5 6 7 8 9 10 11 12
```

**方式2：行指针**

```c
int arr[3][4] = {{1,2,3,4}, {5,6,7,8}, {9,10,11,12}};

// 定义行指针：指向"一维数组"的指针
int (*p)[4];  // p 是指向"含4个int的数组"的指针
              // 注意括号！没括号就成了指针数组

p = arr;      // arr 的类型就是 int (*)[4]

// 使用行指针
printf("%d\n", p[0][0]);      // 输出: 1
printf("%d\n", p[1][2]);      // 输出: 7
printf("%d\n", (*(p+1))[2]);  // 输出: 7 (等价写法)
```

行指针的算术规则相应的也跟普通指针不同：

```c
int (*p)[4];  // p每次+1，跳过4个int（一整行）

p = arr;
p + 0;  // 指向第0行，地址假设1000
p + 1;  // 指向第1行，地址是1016 (跳过4个int = 16字节)
p + 2;  // 指向第2行，地址是1032
```



**访问`[1][2]`的多种方式**

```c
// 访问arr[1][2]的多种方式：
arr[1][2]          // 最直观
*(arr[1] + 2)      // arr[1]是第1行的首地址
*(*(arr + 1) + 2)  // arr+1是第1行的地址，*(arr+1)是第1行的首地址
```



## 5.指针与函数

### 5.1 传址调用（修改原变量）

```c
// 不使用指针（值传递）- 无法修改原变量
void swap_wrong(int a, int b) {
    int temp = a;
    a = b;
    b = temp;
}

// 使用指针（地址传递）- 可以修改原变量
void swap_correct(int *a, int *b) {
    int temp = *a;
    *a = *b;
    *b = temp;
}

int main() {
    int x = 5, y = 10;
    
    swap_wrong(x, y);
    printf("错误方式: x=%d, y=%d\n", x, y);  // 输出: 5, 10（未改变）
    
    swap_correct(&x, &y);
    printf("正确方式: x=%d, y=%d\n", x, y);  // 输出: 10, 5（已交换）
    
    return 0;
}
```

### 5.2 函数返回指针

```c
int* create_array() {
    static int arr[5] = {1, 2, 3, 4, 5};
    return arr;  // 返回数组的首地址
}
```



### 5.3（重难点）函数指针数组





## 6.常见指针类型

### 6.1 空指针

```c
int *p = NULL;  // 不指向任何有效内存
if (p != NULL) {
    *p = 10;    // 使用前检查，避免崩溃
}
```

### 6.2 指针的指针（二级指针）

```c
int num = 10;
int *p = &num;      // p 指向 num
int **pp = &p;      // pp 指向 p

printf("%d\n", **pp);  // 输出: 10
```



### 6.3 常量指针 vs 指针常量

了解即可

```c
int a = 10, b = 20;

// 指向常量的指针：不能通过指针修改值，但指针本身可以改
const int *p1 = &a;
// *p1 = 30;  // 错误！
p1 = &b;      // 正确

// 指针常量：指针不能改变指向，但可以修改值
int *const p2 = &a;
*p2 = 30;     // 正确
// p2 = &b;   // 错误！

// 指向常量的常量指针：都不能改
const int *const p3 = &a;
```

