链表需要动态分配内存，而我们下面介绍的函数就是操作内存的核心工具。

## malloc() - 动态内存分配

### 1.1 什么是 malloc？

```c
#include <stdlib.h>

void* malloc(size_t size);
```

作用：在堆（heap）上分配指定大小的内存，返回指向该内存的指针。

### 1.2 为什么需要 malloc？

```c
// 静态分配（编译时确定大小）
int arr[10];  // 只能存10个元素，不能动态改变

// 动态分配（运行时确定大小）
int n;
printf("需要多少个元素？");
scanf("%d", &n);
int *arr = (int*)malloc(n * sizeof(int));  // 可以根据需要分配
```

### 1.3 malloc 的关键点

```c
// ✅ 正确用法
int *p = (int*)malloc(sizeof(int));  // 分配
if (p != NULL) {
    *p = 100;      // 使用
    free(p);       // 释放
    p = NULL;      // 避免悬空指针
}

// ❌ 常见错误
int *p = (int*)malloc(sizeof(int));
// 忘记检查 NULL
*p = 100;  // 如果分配失败，这里会崩溃

// 忘记 free
// 导致内存泄漏！

// 重复 free
free(p);
free(p);  // 危险！
```

## memset() - 内存初始化

### 2.1 什么是 memset？

```c
#include <string.h>

void* memset(void *ptr, int value, size_t num);
```

作用：将一块内存的每个字节都设置为指定的值（初始化）。

参数：

- ptr：要设置的内存地址

- value：要设置的值（会转换为 unsigned char）

- num：要设置的字节数

### 2.2 基本用法

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {
    // 1. 初始化数组为 0
    int arr[5];
    memset(arr, 0, sizeof(arr));
    
    for (int i = 0; i < 5; i++) {
        printf("%d ", arr[i]);  // 输出: 0 0 0 0 0
    }
    printf("\n");
    
    // 2. 初始化字符数组
    char str[10];
    memset(str, 'A', sizeof(str) - 1);
    str[9] = '\0';  // 字符串结尾
    printf("%s\n", str);  // 输出: AAAAAAAAA
    
    // 3. 配合 malloc 使用
    int *p = (int*)malloc(5 * sizeof(int));
    if (p != NULL) {
        memset(p, 0, 5 * sizeof(int));  // 初始化为 0
        
        for (int i = 0; i < 5; i++) {
            printf("%d ", p[i]);  // 输出: 0 0 0 0 0
        }
        printf("\n");
        
        free(p);
    }
    
    return 0;
}
```



### 2.3 重要注意事项

```c
// ✅ 正确：初始化为 0
int arr[5];
memset(arr, 0, sizeof(arr));

// ❌ 错误：初始化为其他值（对于 int 数组）
memset(arr, 1, sizeof(arr));  // 每个字节都是1，但 int 是4字节
// 结果：arr[0] = 0x01010101 = 16843009 (不是1！)

// ✅ 正确：对于 char 数组可以设置任意值
char str[10];
memset(str, 'A', sizeof(str));  // OK，每个字节是 'A'

// ⚠️ 为什么只用 0？
// 因为 memset 是按字节设置的
// 对于多字节类型（int, double），只有 0 是安全的
// 0 的二进制全是 0，无论多少字节都是 0
```

### 2.4 memset vs 循环赋值

```c
// 方法1：memset（快）
int arr[1000];
memset(arr, 0, sizeof(arr));

// 方法2：循环（慢）
for (int i = 0; i < 1000; i++) {
    arr[i] = 0;
}

// memset 是底层优化的，通常比循环快
```





## memcpy() - 内存拷贝

### 3.1 什么是 memcpy？

```c
#include <string.h>

void* memcpy(void *dest, const void *src, size_t num);
```

作用：将一块内存的内容复制到另一块内存（源内存 -> 目标内存）。

参数：

- dest：目标内存地址

- src：源内存地址

- num：要复制的字节数



### 3.2 基本用法

```c
#include <stdio.h>
#include <string.h>

int main() {
    // 1. 复制数组
    int src[5] = {10, 20, 30, 40, 50};
    int dest[5];
    
    memcpy(dest, src, sizeof(src));
    
    printf("源数组: ");
    for (int i = 0; i < 5; i++) {
        printf("%d ", src[i]);
    }
    printf("\n");
    
    printf("目标数组: ");
    for (int i = 0; i < 5; i++) {
        printf("%d ", dest[i]);
    }
    printf("\n");
    
    // 2. 复制字符串
    char str1[20] = "Hello";
    char str2[20];
    
    memcpy(str2, str1, strlen(str1) + 1);  // +1 包括 '\0'
    printf("复制的字符串: %s\n", str2);
    
    // 3. 部分复制
    int arr1[5] = {1, 2, 3, 4, 5};
    int arr2[5] = {0};
    
    memcpy(arr2, arr1, 3 * sizeof(int));  // 只复制前3个
    
    printf("部分复制: ");
    for (int i = 0; i < 5; i++) {
        printf("%d ", arr2[i]);  // 输出: 1 2 3 0 0
    }
    printf("\n");
    
    return 0;
}
```

### 3.3 memcpy vs strcpy

```c
char str1[20] = "Hello";
char str2[20];

// strcpy：专门用于字符串，自动处理 '\0'
strcpy(str2, str1);

// memcpy：需要手动指定字节数
memcpy(str2, str1, strlen(str1) + 1);

// memcpy 更通用，可以复制任何类型
int arr1[5] = {1, 2, 3, 4, 5};
int arr2[5];
memcpy(arr2, arr1, sizeof(arr1));  // strcpy 不能用于 int 数组
```

### 3.4 重要警告：不能复制重叠内存

```c
int arr[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

// ❌ 危险：源和目标重叠
memcpy(arr + 2, arr, 5 * sizeof(int));  // 未定义行为

// ✅ 正确：使用 memmove
memmove(arr + 2, arr, 5 * sizeof(int));  // 可以处理重叠
```

## 数据结构

内存中如何处理数据的，就叫数据结构

### 1.线性表

由 n 个相同类型的数据元素组成的有限序列。

#### 关键特点：

1）有序
2）有限：元素个数有限
3）同类型：所有元素的数据类型相同



### 2.顺序存储

把线性表的元素按照逻辑顺序依次存放在一块连续的内存空间中。

#### 本质：

就是用数组实现线性表！

#### 顺序表的优缺点

优点：

- ✅ 随机访问快：O(1) 时间访问任意元素

缺点：

- ❌ 插入删除慢：平均 O(n)，需要移动大量元素

- ❌ 固定大小（静态数组）：容易溢出或浪费

- ❌ 扩容成本高（动态数组）：需要复制所有元素

- ❌ 不适合频繁插入删除的场景

适用：固定大小、查询为主的场景



### 3.链式存储（链表）

顺序存储的问题：

- ❌ 插入删除需要移动大量元素

- ❌ 大小固定，不灵活

链式存储的解决方案：

- ✅ 插入删除只需改指针，O(1)

- ✅ 大小动态，按需分配

- ❌ 但是随机访问变慢了，O(n)
