## 链表

顺序存储的问题：

- ❌ 插入删除需要移动大量元素

- ❌ 大小固定，不灵活

链式存储的解决方案：

- ✅ 插入删除只需改指针，O(1)

- ✅ 大小动态，按需分配

- ❌ 但是随机访问变慢了，O(n)

### 1.1什么是链表

链表：由一系列节点（Node） 组成，每个节点包含：

1. 数据域（data）：存储实际数据

1. 指针域（next）：指向下一个节点的地址

```c
// 单个节点的结构
typedef struct Node {
    int data;           // 数据域：存储数据
    struct Node *next;  // 指针域：指向下一个节点
} Node;
```



### 1.2 头指针

一个指针变量，指向链表的第一个节点

```c
// 头指针：指向链表的第一个节点
Node *head = NULL;  // 空链表
```

图解：

```
头指针（一个变量）
    ↓
  head ────→ [10|●] → [20|●] → [30|NULL]
  (变量)      节点      节点      节点
  
head 只是一个指针变量，占8字节（64位系统）
它存储的是第一个节点的地址
```



### 1.3节点结构图

链表分带不带头节点的链表

不带头节点的链表:

这种情况下，头指针直接指向第一个有效数据节点。但 **空表和非空表操作不统一（需要特殊处理空表）**

带头节点的链表（更常用！）

这种情况下，头指针指向一个"哨兵节点"（头节点），头节点不存有效数据。

```c
单个节点：
┌─────────┬─────────┐
│  data   │  next   │
├─────────┼─────────┤
│   10    │   ●─────┼──→ 指向下一个节点
└─────────┴─────────┘

// 带头节点的链表
Node *head = (Node*)malloc(sizeof(Node));  // 创建头节点
head->data = 0;      // 不存有效数据（或存储链表长度等信息）
head->next = NULL;

// 插入数据10, 20, 30后：
带头节点（哨兵节点）的完整链表：
head ────→ [哨兵|●] → [10|●] → [20|●] → [30|NULL]
(头指针)    头节点      第一个    第二个    第三个
           (不存数据)   有效节点   有效节点  有效节点
    

// 不带头节点的链表
Node *head = NULL;

// 插入数据10, 20, 30后：
head ────→ [10|●] → [20|●] → [30|NULL]
(头指针)    第一个     第二个    第三个
           有效节点    有效节点   有效节点

```



### 1.4 链表的基础操作

仅展示部分，全部可见我源代码 “work-project1031_list” 部分

前置

```c
// 菜单结构体 做为数据
typedef struct menu
{
	int menuID;
	char menuName[20];
	double price;	
}MENU;

// 链表的结点结构体
typedef struct list
{
	MENU data; // 数据域 : 菜单结构体变量
	struct list * pnext; // 指针域 ：指向下一个节点的指针
		
}LIST; 
```

#### 1.4.1 尾插法 List_pushback()

在末尾添加节点

```c
void  List_pushback(LIST * head, MENU menu)
{
	
	// 1. 检查头节点
	if(head == NULL)
	{
		printf("链表创建失败，内存分配失败\n");
		return ;	
	} 
	
	// 2.创建新结点
	LIST * newNode = (LIST *)malloc(sizeof(LIST));	
	
	if(newNode == NULL)
	{
		printf("错误：新节点创建失败");		
		return; 
	} 
	
	// 3.初始化新节点 
	memset(newNode,0,sizeof(LIST)); 
	newNode -> data = menu;  // 存储菜单数据
	newNode -> pnext = NULL; // 新节点是新的尾节点
    
    
    
	// 4. 找到当前的尾节点
	LIST * ptemp = head;		// 从头节点开始
	while(ptemp -> pnext != NULL)
	{
		ptemp = ptemp -> pnext;	 // 一直往后走
	}	
	// 循环结束时，ptemp指向最后一个节点
    
    // 5. 将新节点连接到尾部
	ptemp -> pnext = newNode;
	
	
	printf("新节点添加成功！\n");
}
```



#### 1.4.2 头插法  List_pushfront()

在链表头部插入节点（比尾插快！）

```c
/*
    头插法：在头部插入新节点
    时间复杂度：O(1)
    
    原链表：head → [哨兵|●] → [菜品1|●] → [菜品2|NULL]
    插入后：head → [哨兵|●] → [新菜品|●] → [菜品1|●] → [菜品2|NULL]
*/
void List_pushfront(LIST *head, MENU menu) {
    if(head == NULL) {
        printf("链表不存在！\n");
        return;
    }
    
    // 1. 创建新节点
    LIST *newNode = (LIST *)malloc(sizeof(LIST));
    if(newNode == NULL) {
        printf("内存分配失败！\n");
        return;
    }
    
    // 2. 初始化新节点
    memset(newNode, 0, sizeof(LIST));
    newNode->data = menu;
    
    // 3. 头插 先将newNode尾巴接上 再跟head相接
    newNode->pnext = head->pnext;  // 新节点指向原来的第一个节点
    head->pnext = newNode;         // 头节点指向新节点
    
    printf("头插成功！\n");
}
```

#### 1.4.3 按值查找  findByID()

根据菜品ID查找节点

```c
/*
    根据菜品ID查找节点
*/
LIST* findByID(LIST *head, int menuID) {
    if(head == NULL) {
        return NULL;
    }
    
    LIST *p = head->pnext;  // 从第一个有效节点开始
    
    while(p != NULL) {
        if(p->data.menuID == menuID) {
            return p;  // 找到了
        }
        p = p->pnext;
    }
    
    return NULL;  // 未找到
}
```

#### 1.4.4 按值删除 deleteByID()

根据菜品ID删除节点

```c
/*
    根据菜品ID删除节点
*/
int deleteByID(LIST *head, int menuID) {
    if(head == NULL) {
        return 0;
    }
    
    LIST *ppre = head;      // 前驱节点
    LIST *p = head->pnext;  // 当前节点
    
    // 查找目标节点
    while(p != NULL) {
        if(p->data.menuID == menuID) {
            // 找到了，删除
            ppre->pnext = p->pnext;
            free(p);
            printf("删除成功！\n");
            return 1;
        }
        ppre = p;
        p = p->pnext;
    }
    
    printf("未找到该菜品！\n");
    return 0;
}
```

#### 1.4.5 清空链表 List_clear()

删除所有节点（保留头节点）

```c
/*
    清空链表（保留头节点）
*/
void List_clear(LIST *head) {
    if(head == NULL) {
        return;
    }
    
    LIST *p = head->pnext;
    
    // 遍历删除所有节点
    while(p != NULL) {
        LIST *temp = p;
        p = p->pnext;
        free(temp);
    }
    
    // 头节点的next指向NULL
    head->pnext = NULL;
    printf("链表已清空！\n");
}
```



#### 1.4.6 销毁链表  List_destroy()

删除所有节点，包括头节点

```c
/*
    销毁链表（包括头节点）
*/
void List_destroy(LIST **head) {
    if(*head == NULL) {
        return;
    }
    
    // 先清空所有节点
    List_clear(*head);
    
    // 释放头节点
    free(*head);
    *head = NULL;  // 将头指针设为NULL
    
    printf("链表已销毁！\n");
}
```



#### ！重要混淆点：为什么销毁链表传的不是 LIST *head

因为指针本身也是一个变量，它也会有"传副本"的问题！

```c
#include <stdio.h>
#include <stdlib.h>

// 试图把指针改成 NULL（错误的方式）
void setNull_wrong(int *p) 
{
    p = NULL;  // 这只是改了副本！
    printf("函数内：p = %p\n", p);  // NULL
}

int main() 
{
    int *ptr = (int*)malloc(sizeof(int));
    *ptr = 100;
    
    printf("调用前：ptr = %p\n", ptr);  // 有地址，比如 0x2000
    
    setNull_wrong(ptr);  // 传值（传的是指针的副本）
    
    printf("调用后：ptr = %p\n", ptr);  // 还是 0x2000，没变！
    
    return 0;
}
```

**图解：为什么没改**

```
内存：
地址 0x3000
┌─────────┐
│  ptr    │
│ 0x2000  │  ← ptr 本身也是个变量，存的是地址 0x2000
└─────────┘
     ↓ 指向
地址 0x2000
┌─────────┐
│  100    │  ← 实际的数据
└─────────┘

调用 setNull_wrong(ptr):
复制指针的值 →   ┌─────────┐
                │   p     │
                │ 0x2000  │  ← p 是 ptr 的副本
                └─────────┘

在函数内 p = NULL:
┌─────────┐     ┌─────────┐
│  ptr    │     │   p     │
│ 0x2000  │     │  NULL   │  ← 只改了副本 p
└─────────┘     └─────────┘
   ↑
  没变！
```



**要改变一个变量，就传它的地址；要改变一个指针，就传指针的地址（二级指针）**

#### 规律

```
要改变什么？              需要传什么？
─────────────────────────────────────
int 变量                  int* (一级指针)
int* 指针变量             int** (二级指针)
int** 二级指针变量        int*** (三级指针)
```

