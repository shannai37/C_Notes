## if语句相关

### 错题1

```C
	int x;
	scanf("%d",&x);
	if(x--<5) printf("%d",x);
	else printf("%d",x++);	
```

输入5，最后打印结果是？





## 猜拳游戏：

1表示石头 2表示剪刀 3表示布

人出拳，键盘输入（1，2，3任意的整数）

输完后电脑随机生成1、2、3任意的整数代表出的拳；

电脑随机出拳

然后玩几局（比如五局），定输赢：

展示效果如图：

![image-20251009205701622](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20251009205701622.png)







## 用户名与密码的输入：



用户名只能输入字母，并且最多12位；按回车结束输入

密码只能输入数字，并且最多8位，按回车结束输入



## -----------------------

## if_错题1解析

**无论输入什么，if条件中的 `x--` 总是会将x减1！**

所以

输入5，`x-- < 5`：先比较 `5 < 5` → `false`，然后 `x = 5-1 = 4`

执行else分支：打印 `4`，然后 `x = 4+1 = 5`



## 猜拳游戏解析：

答的不好，而且有的部分我并不了解或者熟悉，所以重写了一遍

#### 1.为什么使用指针数组存`"石头"`、`"剪刀"`、`"布"`呢？

```c
char *choices[3] = {"石头", "剪刀", "布"};
```

`"石头"`、`"剪刀"`、`"布"` 这些是**字符串字面量**（"C04_数组"那一节会详细解释）

字符串字面量在表达式中会退化为指向其首字符的指针，

```c
//先简单补充一下,首字符是什么？中文还适用吗：
char *arr[] = {"hello", "world", "test"};
//arr[0] 是一个 char *，指向 "hello" 的第一个字符 'h'
//arr[1]、arr[2]同理

//数组名 arr 在大多数情况下会退化为指向首元素的指针
//首元素是arr[0]，arr[0] 的地址就是 &arr[0]，arr 实际上是 &arr[0]，也就是指向第一个指针的地址

//"石头" 在内存中是什么样？假设是UTF-8编码（一个中文字符通常占 3个字节）：
char *choices[3] = {"石头", "剪刀", "布"};

"石头" = [石的字节1][石的字节2][石的字节3][头的字节1][头的字节2][头的字节3][\0]
//总共7个字节（6个字节表示两个汉字 + 1个\0）
    
//变成中文后，"退化为指向其首字符的指针" 依然成立，但是这里的"字符"指的是首字节，并不是单个汉字。
//choices[0] 这个指针依然是指向字符串的首字节，也就是"石"字的第一个字节   
```

所以用指针数组来存储最合适。

不使用指针数组也可以使用二维数组

```c
char choices[3][10] = {"石头", "剪刀", "布"};  // 需要指定最大长度
```

**缺点**：

- 必须预先分配固定长度（这里10个字符）
- 浪费内存空间（"石头"只用4字节，但分配了10字节）
- 不够灵活

或者我刚开始想的这种写法

```c
char choices[3] = {"石头", "剪刀", "布"};  // 错误！
```

这会编译错误，因为不能把字符串赋值给单个字符

2.读取玩家输入的核心如下：

```c
int player;
player = getch() - '0';
```

#### getch()返回的不是int类型吗？为什么还要-'0'  ,  -'0'的功能是什么？



虽然 `getch()` 返回 `int`，但它返回的是字符的 **ASCII 码值**，而不是字符本身代表的数值。

比如我们想要的是0，但它返回的是0的**ASCII码值**48！

- `ch - '0'` 是标准的将数字字符转换为对应数值的方法



整体代码：

```c
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <conio.h>  // 对于getch()

void module12()//猜拳
{
	char *choices[3] = {"石头", "剪刀", "布"};

	srand(time(NULL));
	
	while(1)
	{
		printf("1表示石头\n2表示剪刀\n3表示布");
		int i,player,computer,count = 0;//count用于计算玩家胜利次数 
	
		for(i = 0 ; i < 5 ; i++)
		{
			printf("请出拳:\n");
			player = getch() - '0';//getch()读入是字符，将字符转换为数字 
			computer = 1 + rand() % 3 ;
			if (player < 1 || player > 3) 
			{
		        printf("请输入1-3之间的数字!\n");
		        return 1;
    		}
			printf("您出了: %s,", choices[player-1]);
    		printf("电脑出了: %s\n", choices[computer-1]);
			if (player == computer) 
			{
        		printf("平局！\n");			
			}
			else if ( (player == 1 && computer == 2) ||  // 石头 vs 剪刀
               (player == 2 && computer == 3) ||  // 剪刀 vs 布
               (player == 3 && computer == 1) ) 	// 布 vs 石头
			   {  
       			 printf("您赢了！\n");
       			 count++;
   			   } 
			else 
			{
        		printf("您输了！\n");
    		}
		}
		printf("在%d局游戏中，您赢了%d次\n",i,count);
		return;
	}
} 
```



## 用户名与密码解析：

使用并不熟练，所以拿出来复习

#### 1.不同系统的换行符差异：

在我的笔记“C_02输入输出与运算符”就讲到过，

**`\n`**：换行，光标移动到下一行

**`\r` **：回车，光标移动到行首

上面是对windows的。但是不同系统对换行符的定义不同

| 系统             | 换行符 | 说明       |
| :--------------- | :----- | :--------- |
| Unix/Linux/macOS | `\n`   | 只用换行符 |
| Windows          | `\r\n` | 回车+换行  |
| 经典Mac系统      | `\r`   | 只用回车符 |

所以要检测enter，可以采用下面的形式

```C
// 同时检查两种换行符，提高兼容性
        if(ch == '\n' || ch == '\r') break;
```

#### 2.清空缓冲区怎么写：

```c
int ch;
//清理缓冲区，为下次读取做准备 
	while ((ch = getchar()) != '\n' && ch != EOF);
```

为什么推荐使用 `int` 而不是 `char`呢？

```c
int ch;  // 推荐使用int，而不是char
while ((ch = getchar()) != '\n' && ch != EOF);
```

**原因**：

- `getchar()` 返回 `int` 类型
- `EOF` 通常是 -1，如果保存在 `char` 中可能被误认为是普通字符
- 使用 `int` 可以正确区分所有可能的返回值





简化版本（一般够用）：

```c
while (getchar() != '\n');  // 只检查换行符
```

整体代码：

```C
void module9()//用户名和密码的输入
{
	char str[13],num[9],ch;
	int user = 0,pw = 0;
	printf("请输入用户名,最大长度为12位:");
	while(user < 12) //限制用户名长度为12位 
	{
		ch = getchar();
		if(ch == '\n') break;
		if(isalpha(ch)) //如果是字母,才会纪录 
		{
			str[user++] = ch;
		}
	}
	//清理缓冲区，为下次读取做准备 
	while ((ch = getchar()) != '\n' && ch != EOF);
	
	printf("请输入密码,最大长度为8位:");
	while(pw < 8)
	{
		ch = getchar();
		if(ch == '\n') break;
		if(isdigit(ch))
		{
			num[pw++] = ch;
		}
	}
	// 清除缓冲区 
    while ((ch = getchar()) != '\n' && ch != EOF);
	//输出 
	int i;
	printf("您的用户名是:");
	for(i = 0 ; i < user ; i++)
	{
		printf("%c",str[i]);
	}
	printf("\n");
	printf("您的密码是:");
	for(i = 0 ; i < pw ; i++)
	{
		printf("%c",num[i]);
	}
	printf("\n");
} 
```

