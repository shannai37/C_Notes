

## 数据持久化

将程序运行时的数据保存到硬盘，这样程序关闭后数据不会丢失。

```
内存中的数据（易失性）
   ↓ 持久化（保存）
文件中的数据（永久性）
   ↓ 读取（加载）
内存中的数据（易失性）
```

## IO流

I   in输入   进入内存（读） 			scanf：键盘 -> 内存中程序

O out输出  离开内存（写）			printf：内存中程序->屏幕

口诀  读入  写出



## 文件分类

1.二进制文件：每一个字节放一个ASCII代码

2.文本文件：把内存中的数据按其在内存中的存储形
式原样输出到磁盘上存放

![image-20251101160941295](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20251101160941295.png)



## 文件操作

### 1.基本流程

```c
// 标准流程
FILE *fp;                    // 1. 声明文件指针
fp = fopen("data.txt", "r"); // 2. 打开文件
// ... 进行读写操作 ...      // 3. 操作文件
fclose(fp);                  // 4. 关闭文件
```

### 2.文件打开模式

| 模式       | 说明       | 文件不存在     | 文件存在                               |
| :--------- | :--------- | :------------- | :------------------------------------- |
| "r"        | 只读       | 失败           | 从头读取                               |
| "w"        | 只写       | 创建新文件     | 清空原内容                             |
| "a"        | 追加写     | 创建新文件     | 追加到末尾                             |
| "r+"       | 读写       | 失败           | 从头开始写，不对指针处理会覆盖原先内容 |
| "w+"       | 读写       | 创建新文件     | 清空原内容                             |
| "a+"       | 读写追加   | 创建新文件     | 追加到末尾                             |
| "rb", "wb" | 二进制模式 | 用于非文本文件 | -                                      |



### 3.常用文件操作函数速查表

| 函数      | 用途           | 示例                               |
| :-------- | :------------- | :--------------------------------- |
| fopen()   | 打开文件       | fp = fopen("data.txt", "r")        |
| fclose()  | 关闭文件       | fclose(fp)                         |
| fprintf() | 格式化写入文本 | fprintf(fp, "%d\n", num)           |
| fscanf()  | 格式化读取文本 | fscanf(fp, "%d", &num)             |
| fwrite()  | 写入二进制数据 | fwrite(&data, sizeof(data), 1, fp) |
| fread()   | 读取二进制数据 | fread(&data, sizeof(data), 1, fp)  |
| fgets()   | 读取一行文本   | fgets(str, 100, fp)                |
| fputs()   | 写入一行文本   | fputs("hello\n", fp)               |
| fseek()   | 移动文件指针   | fseek(fp, 0, SEEK_SET)             |
| ftell()   | 获取当前位置   | pos = ftell(fp)                    |



## 个人课程感悟

### 1.fread参数理解

#### 函数原型

```c
size_t fread(void *buffer, size_t size, size_t count, FILE *stream);
//           ↑存储位置      ↑每单元字节   ↑读取单元数  ↑文件指针
//           返回值：成功读取的单元数
```

#### 方式1：把整个buf当作1个单元（容易出错）

```c
// 错误示范：要求一次性读满10字节才算1个单元
res = fread(buf, sizeof(buf), 1, fp);
//            ↑10字节为1单元  ↑读1个单元

// 问题：如果文件只有6字节（比如"Hello"）
// 结果：res=0（没读满10字节，算0个单元）
// 但实际buf里有数据！这很容易误导！
```

#### 方式2：1字节=1单元（推荐）

```c
// 正确做法：每1字节算1个单元
res = fread(buf, 1, sizeof(buf), fp);
//            ↑1字节为1单元  ↑最多读10个单元

// 如果文件只有6字节
// 结果：res=6（成功读取6个单元）
// 返回值能准确反映读到了多少数据！
```



### 2.循环读取大文件的标准模式

```c
// 标准的分批读取模式
while( (res = fread(buf, 1, sizeof(buf), fp)) > 0 )
{
    // 1. 处理本次读取的数据
    printf("本次读取了 %d 字节\n", res);
    printf("内容：%s\n", buf);
    
    // 2. ⚠️ 重点：清空缓冲区
    memset(buf, 0, sizeof(buf));
}
```



#### 为什么要memset清空缓冲区？

```c
// 假设文件内容："HelloWorld123"（13字节）
// buf大小：10字节

// 第1次循环：读取 "HelloWorld"（10字节）
buf = "HelloWorld"

// 第2次循环：读取 "123"（3字节）
// 如果不清空，buf = "123loWorld"  ← 后面是上次的残留！
//                       ↑新数据 ↑旧数据
// 清空后，   buf = "123\0\0\0\0\0\0\0"  ← 正确！
```



### 3.文件拷贝（读写配合）

```c
void demo3() {
    int res = 0;
    char buf[100] = {0};  //  中转站：存储每次读取的数据
    
    FILE *rfp = NULL;     // 读文件指针 (read file pointer)
    FILE *wfp = NULL;     // 写文件指针 (write file pointer)
    
    // 打开两个文件：一个读，一个写
    rfp = fopen("./data/1.txt", "r+");           // 源文件
    wfp = fopen("./data/1-副本.txt", "w+");      // 目标文件
    
    if (rfp != NULL && wfp != NULL) {
        // 核心循环：边读边写
        while ((res = fread(buf, 1, sizeof(buf), rfp)) > 0) {
            //                   ↑从rfp读取    
            //                        ↑实际读到的字节数
            
            fwrite(buf, 1, res, wfp);
            //          ↑写入wfp  
            //              ↑关键：写入实际读到的字节数
            
            memset(buf, 0, sizeof(buf));  // 清空缓冲区
        }
        
        printf("拷贝成功！\n");
        fclose(rfp);
        fclose(wfp);
    }
    else {
        printf("拷贝失败！\n");
    }
}
```

#### 为什么fwrite的第三个参数用res而不是sizeof(buf)？

```c
// 假设文件大小：250字节，buf大小：100字节

// 第1次循环：读取100字节
res = fread(buf, 1, 100, rfp);  // res = 100
fwrite(buf, 1, 100, wfp);       // ✅ 写入100字节

// 第2次循环：读取100字节
res = fread(buf, 1, 100, rfp);  // res = 100
fwrite(buf, 1, 100, wfp);       // ✅ 写入100字节

// 第3次循环：只剩50字节
res = fread(buf, 1, 100, rfp);  // res = 50（没有100字节了）
fwrite(buf, 1, 50, wfp);        // ✅ 只写入50字节
//              ↑必须用res，否则会写入垃圾数据！

// 如果错误地写成：
fwrite(buf, 1, 100, wfp);       // ❌ 多写了50字节的垃圾！
```

#### 为什么说int buf[100]慎用?

```c
char buf[100];  // 100字节  ✅ 合理
int buf[100];   // 400字节  ⚠️ 浪费！（int=4字节）

// 文件拷贝只需要临时存储，char足够
```



### 4.结构体保存（重点：二进制 vs 文本格式）

| 特性       | 二进制格式存储       | 文本格式存储             |
| :--------- | :------------------- | :----------------------- |
| 写入方式   | fwrite(&结构体)      | sprintf → fwrite(字符串) |
| 存储内容   | 内存原始字节         | ASCII字符串              |
| 记事本可读 | ❌ 乱码               | ✅ 正常显示               |
| 文件扩展名 | 通常 .dat/.bin       | 通常 .txt/.csv           |
| 适用场景   | 图片、音频、大量数据 | 配置文件、日志           |

#### 方式1：二进制方式（原始但快）

```c
void method1_binary() {
    STU stu = {"OM0250401", "张三", 20};
    FILE *fp = fopen("./data/test.dat", "wb");
    
    // 直接把整个结构体写入（40字节）
    fwrite(&stu, sizeof(STU), 1, fp);
    //      ↑取地址  ↑整个结构体大小
    
    fclose(fp);
}

// 读取
void readMethod1() {
    STU resStu;
    FILE *fp = fopen("./data/test.dat", "rb");
    
    // 直接读取整个结构体
    fread(&resStu, sizeof(STU), 1, fp);
    
    printf("学号：%s\n", resStu.stuID);
    printf("姓名：%s\n", resStu.stuName);
    printf("年龄：%d\n", resStu.age);
    
    fclose(fp);
}
```



#### 方式2：文本格式（推荐）

```c
void method2_text() {
    STU stu = {"OM0250401", "张三", 20};
    char buf[100] = {0};
    FILE *fp = fopen("./data/test.txt", "w+");
    
    // 关键：sprintf 将结构体数据拼接成字符串
    sprintf(buf, "%s %s %d", stu.stuID, stu.stuName, stu.age);
    //       ↑存储到buf   
    //              ↑格式化字符串           ↑数据来源
    // 结果：buf = "OM0250401 张三 20"
    
    // 写入文本（只需要字符串实际长度）
    fwrite(buf, 1, strlen(buf), fp);
    //              ↑只写有效数据，不写整个buf
    
    fclose(fp);
}

// 读取
void readMethod2() {
    char buf[100] = {0};
    STU resStu = {0};
    FILE *fp = fopen("./data/test.txt", "r+");
    
    // 1. 先读取整行到buf
    fread(buf, 1, sizeof(buf), fp);
    // buf现在是："OM0250401 张三 20"
    
    // 2.  关键：sscanf 按格式拆解字符串
    sscanf(buf, "%s %s %d", 
           resStu.stuID,      // 数组名本身就是指针，不需要&
           resStu.stuName,    // 同上
           &(resStu.age));    // ⚠️ 普通变量需要取地址！
    //  ↑从buf读取  ↑格式   ↑存储位置
    
    printf("学号：%s\n", resStu.stuID);
    printf("姓名：%s\n", resStu.stuName);
    printf("年龄：%d\n", resStu.age);
    
    fclose(fp);
}
```

注意：文件后缀名只是给人看的标识，真正决定"可读性"的是文件内容本身，不是后缀名！

而约定俗成的，二进制格式 → 用 .dat 后缀    文本格式 → 用 .txt 后缀

即使 二进制用txt打开，也是乱码      同样的，即使文本文件用dat打开，也能正常显示。下面是我的测试结果总结

```c
#include <stdio.h>
#include <string.h>

typedef struct {
    char stuID[20];
    char stuName[20];
    int age;
} STU;

int main() {
    STU stu = {"OM0250401", "张三", 20};
    char buf[100];
    
    // 创建4个文件做对比
    
    // 1. 二进制内容 + .dat后缀（标准）
    FILE *f1 = fopen("1_binary.dat", "wb");
    fwrite(&stu, sizeof(STU), 1, f1);
    fclose(f1);
    
    // 2. 二进制内容 + .txt后缀（容易误导）
    FILE *f2 = fopen("2_binary.txt", "wb");
    fwrite(&stu, sizeof(STU), 1, f2);
    fclose(f2);
    
    // 3. 文本内容 + .txt后缀（标准）
    sprintf(buf, "%s %s %d", stu.stuID, stu.stuName, stu.age);
    FILE *f3 = fopen("3_text.txt", "w");
    fwrite(buf, 1, strlen(buf), f3);
    fclose(f3);
    
    // 4. 文本内容 + .dat后缀（容易误导）
    FILE *f4 = fopen("4_text.dat", "w");
    fwrite(buf, 1, strlen(buf), f4);
    fclose(f4);
    
    printf("生成了4个文件，用记事本打开对比：\n\n");
    printf("1_binary.dat - 乱码（标准：二进制用.dat）\n");
    printf("2_binary.txt - 乱码（虽然后缀是.txt，但内容是二进制）\n");
    printf("3_text.txt   - 正常（标准：文本用.txt）\n");
    printf("4_text.dat   - 正常（虽然后缀是.dat，但内容是文本）\n");
    
    return 0;
} printf("1_binary.dat - 乱码（标准：二进制用.dat）\n");

  printf("2_binary.txt - 乱码（虽然后缀是.txt，但内容是二进制）\n");

  printf("3_text.txt  - 正常（标准：文本用.txt）\n");

  printf("4_text.dat  - 正常（虽然后缀是.dat，但内容是文本）\n");
```



#### 核心知识点 sprintf vs sscanf

#### sprintf：拼接字符串（写文件前）

```c
char buf[100];
int age = 20;
float score = 85.5;

// 类似printf，但输出到字符串而不是屏幕
sprintf(buf, "姓名:%s 年龄:%d 成绩:%.2f", "张三", age, score);

// 结果：buf = "姓名:张三 年龄:20 成绩:85.50"
```

#### sscanf ：拆解字符串（读文件后）

```c
char buf[] = "张三 20 85.5";
char name[20];
int age;
float score;

// 类似scanf，但从字符串读取而不是键盘
sscanf(buf, "%s %d %f", name, &age, &score);
//                       ↑数组  ↑变量要加&

// 结果：name="张三", age=20, score=85.5
```



#### 总结

| 方式   | 写入                             | 读取                               | 适用场景             |
| :----- | :------------------------------- | :--------------------------------- | :------------------- |
| 二进制 | fwrite(&stu, sizeof(STU), 1, fp) | fread(&resStu, sizeof(STU), 1, fp) | 性能优先、大量数据   |
| 文本   | sprintf → fwrite                 | fread → sscanf                     | 可读性优先、配置文件 |



### 5.指针 vs 普通变量：链表遍历时的数据读取

#### 链表节点存储结构
```c
typedef struct list {
    void *data;        // 存储的是指针（地址）
    struct list *pnext;
} LIST;
```

**关键**：`temp->data` 本身是一个指针，指向实际数据的内存地址。

#### 方法1：指针方式（推荐）

```c
USER *user = (USER *)(temp->data);
// temp->data 是 void* 类型
// (USER*) 强制转换为 USER* 类型
// user 是指针，直接指向链表中的数据

// 访问成员用 ->
printf("%s\n", user->account);
```

#### 方法2：普通变量方式（可以但不推荐）

```c
USER user = *((USER *)(temp->data));
//          ↑ 注意这个 * 号（解引用）

// 步骤分解：
// 1. (USER*)(temp->data) - 先转换类型
// 2. *(...) - 解引用，取出指针指向的数据
// 3. 赋值给普通变量 user

// 访问成员用 .
printf("%s\n", user.account);
```

#### 两种方式对比

| 特性 | 指针方式 | 普通变量方式 |
|------|---------|------------|
| 写法 | `USER *user = (USER*)(temp->data)` | `USER user = *((USER*)(temp->data))` |
| 内存占用 | 4/8字节（指针大小） | sizeof(USER)字节（整个结构体） |
| 速度 | 快（只复制地址） | 慢（复制整个结构体） |
| 访问成员 | `user->account` | `user.account` |
| 能否修改原数据 | 可以 | 不可以（修改的是副本） |

#### 结论

**链表遍历时使用指针方式：**
- 效率高：不复制数据，只复制地址
- 代码简洁：少写一个 `*` 和括号
- 符合习惯：链表操作通常用指针

**记忆要点：**
```c
指针用 ->    USER *user;  user->account
普通变量用 .  USER user;   user.account
```



### 6.fprintf vs sprintf + fwrite 深入对比

#### 方法A：sprintf + fwrite

```c
void saveUserList(LIST *head, const char *filename) {
    FILE *fp = fopen(filename, "w");
    LIST *temp = head->pnext;
    
    char buf[100] = {0};  // 需要手动创建缓冲区
    
    while (temp != NULL) {
        USER *user = (USER *)(temp->data);
        
        // 第1步：格式化到字符串
        sprintf(buf, "%s %s %d\n", 
                user->account, user->password, user->role);
        
        // 第2步：写入文件
        fwrite(buf, 1, strlen(buf), fp);
        
        temp = temp->pnext;
    }
    
    fclose(fp);
}
```

**数据流程：**
```
程序数据（user结构体）
    ↓
sprintf 格式化
    ↓
buf 数组（手动缓冲区）
    ↓
fwrite 写入
    ↓
FILE* 系统缓冲区
    ↓
磁盘文件
```

#### 方法B：fprintf（推荐）

```c
void saveUserList(LIST *head, const char *filename) {
    FILE *fp = fopen(filename, "w");
    LIST *temp = head->pnext;
    
    // 不需要 buf 数组
    
    while (temp != NULL) {
        USER *user = (USER *)(temp->data);
        
        // 一步完成：格式化并写入文件
        fprintf(fp, "%s %s %d\n", 
                user->account, user->password, user->role);
        
        temp = temp->pnext;
    }
    
    fclose(fp);
}
```

**数据流程：**
```
程序数据（user结构体）
    ↓
fprintf 内部格式化
    ↓
FILE* 系统缓冲区
    ↓
磁盘文件
```

#### 两种方式对比

| 特性 | sprintf + fwrite | fprintf |
|------|-----------------|---------|
| 代码行数 | 3行（定义buf + sprintf + fwrite） | 1行 |
| 需要 buf 数组 | 需要 | 不需要 |
| 数据流程 | 内存 → buf → FILE*缓冲区 → 磁盘 | 内存 → FILE*缓冲区 → 磁盘 |
| 性能 | 几乎相同 | 几乎相同 |
| 代码可读性 | 稍复杂 | 简洁清晰 |

#### 等价关系

```c
// 这两段代码完全等价：

// 写法1
sprintf(buf, "%s %s %d\n", str1, str2, num);
fwrite(buf, 1, strlen(buf), fp);

// 写法2
fprintf(fp, "%s %s %d\n", str1, str2, num);
```

**fprintf 内部就是做了 sprintf + fwrite 的工作。**

#### 常用格式化函数对比

| 函数 | 输出目标 | 格式 | 典型用途 |
|------|---------|------|---------|
| `printf` | 屏幕（标准输出） | `printf("格式", 数据)` | 调试、显示信息 |
| `sprintf` | 字符串 | `sprintf(buf, "格式", 数据)` | 字符串处理、中间格式化 |
| `fprintf` | 文件 | `fprintf(fp, "格式", 数据)` | 写入文件（推荐） |

#### 读取对应的函数

| 写入函数 | 读取函数 | 数据流程 |
|---------|---------|---------|
| `printf` | `scanf` | 内存 ↔ 屏幕 |
| `sprintf` | `sscanf` | 内存 ↔ 字符串 |
| `fprintf` | `fscanf` | 内存 ↔ 文件 |
| `fwrite` | `fread` | 内存 ↔ 文件（二进制） |



### 7.fscanf vs fgets + sscanf 深入对比

#### 方法A：fgets + sscanf

```c
LIST* getUserList(const char *filename) {
    FILE *fp = fopen(filename, "r");
    LIST *head = New_List_Init();
    
    if (fp == NULL) return head;
    
    char buf[100];  // 需要中间缓冲区
    
    while (fgets(buf, sizeof(buf), fp) != NULL) {
        USER user;
        
        // 第1步：读取一行到 buf
        // 第2步：解析 buf
        sscanf(buf, "%s %s %d", 
               user.account, user.password, &user.role);
        
        New_List_pushback(head, &user, sizeof(USER));
    }
    
    fclose(fp);
    return head;
}
```

**数据流程：**
```
磁盘文件
    ↓
FILE* 系统缓冲区
    ↓
fgets 读取一行
    ↓
buf 数组（中间缓冲）
    ↓
sscanf 解析
    ↓
user 结构体
```

#### 方法B：fscanf（推荐）

```c
LIST* getUserList(const char *filename) {
    FILE *fp = fopen(filename, "r");
    LIST *head = New_List_Init();
    
    if (fp == NULL) return head;
    
    USER user;
    
    // 直接从文件读取并解析，一步到位
    while (fscanf(fp, "%s %s %d", 
                  user.account, user.password, &user.role) == 3) {
        //                                                    ↑ 返回成功读取的项数
        New_List_pushback(head, &user, sizeof(USER));
    }
    
    fclose(fp);
    return head;
}
```

**数据流程：**
```
磁盘文件
    ↓
FILE* 系统缓冲区
    ↓
fscanf 直接解析
    ↓
user 结构体
```

#### 两种方式对比

| 特性 | fgets + sscanf | fscanf |
|------|---------------|--------|
| 代码行数 | 3行（定义buf + fgets + sscanf） | 1行 |
| 需要 buf 数组 | 需要 | 不需要 |
| 数据流程 | 文件 → buf → 解析 | 文件 → 直接解析 |
| 循环判断 | `!= NULL` | `== 3`（返回读取项数） |
| 代码可读性 | 稍复杂 | 简洁清晰 |

#### 等价关系

```c
// 这两段代码完全等价：

// 写法1
fgets(buf, sizeof(buf), fp);
sscanf(buf, "%s %s %d", user.account, user.password, &user.role);

// 写法2
fscanf(fp, "%s %s %d", user.account, user.password, &user.role);
```

**fscanf 内部就是做了 fgets + sscanf 的工作。**

#### fscanf 返回值详解

```c
int result = fscanf(fp, "%s %s %d", user.account, user.password, &user.role);
//  ↑返回值                                ↑ 3个格式符

// 返回值：
// 3   - 成功读取3个数据项
// 2   - 只读取了2个（格式不匹配或数据不完整）
// 1   - 只读取了1个
// 0   - 一个都没读取到
// EOF - 到达文件末尾或出错
```

**循环条件：**
```c
while (fscanf(fp, "%s %s %d", ...) == 3) {
    // 确保3个数据都读取成功
}
```

#### 完美对称：文件读写

```c
// ===== 写入 =====
fprintf(fp, "%s %s %d\n", user->account, user->password, user->role);

// ===== 读取 =====
fscanf(fp, "%s %s %d", user.account, user.password, &user.role);
```

#### 什么时候用 fgets + sscanf？

虽然 fscanf 更简洁，但有些场景必须用 fgets + sscanf：

**场景：需要读取包含空格的完整行**
```c
// 文件内容：Hello World 123

// fscanf 会把空格当分隔符
fscanf(fp, "%s %d", str, &num);  // str = "Hello", 读取失败

// fgets 可以读取整行
fgets(buf, sizeof(buf), fp);  // buf = "Hello World 123\n"
```

#### 推荐用法总结

| 场景 | 推荐方法 | 原因 |
|------|---------|------|
| 简单格式（空格分隔） | fprintf + fscanf | 代码简洁、对称 |
| 包含空格的字符串 | fprintf + fgets/sscanf | 需要整行读取 |



### 8.其他文件操作函数

#### 8.1 fseek - 移动文件指针

```c
// 1. fseek - 移动文件指针
int fseek(FILE *fp, long offset, int origin);
//                   ↑偏移量      ↑起始位置
```

| 参数     | 值   | 含义     | 示例                                      |
| :------- | :--- | :------- | :---------------------------------------- |
| SEEK_SET | 0    | 文件开头 | fseek(fp, 10, SEEK_SET) - 跳到第10字节    |
| SEEK_CUR | 1    | 当前位置 | fseek(fp, 5, SEEK_CUR) - 向前移5字节      |
| SEEK_END | 2    | 文件末尾 | fseek(fp, -10, SEEK_END) - 末尾往回10字节 |

#### 8.2 ftell - 获取当前位置

```c
// 2. ftell - 获取当前位置
long ftell(FILE *fp);  // 返回当前位置（字节数）
```



#### 8.3 rewind - 回到文件开头

```c
// 3. rewind - 回到文件开头

void rewind(FILE *fp);  // 等价于 fseek(fp, 0, SEEK_SET)
```





#### 8.4 feof - 检查是否到达文件末尾

```c
// 4. feof - 检测是否到达文件末尾
int feof(FILE *fp);  // 返回非0表示到达末尾
```





#### 实用示例函数

##### 示例1：获取文件大小

```c
long getFileSize(const char *filename) {
    FILE *fp = fopen(filename, "r");
    if (fp == NULL) 
    {
        printf("文件打开失败\n");
        return -1;
    }
    
    // 移动到文件末尾
    fseek(fp, 0, SEEK_END);
    
    // 获取当前位置（就是文件大小）
    long size = ftell(fp);
    
    fclose(fp);
    return size;
}

// 使用
int main() {
    long size = getFileSize("./data/user1.txt");
    printf("文件大小：%ld 字节\n", size);
    return 0;
}
```

##### 示例2：读取文件的第N行

```c
// 读取文件的第N行（从1开始计数）
int readNthLine(const char *filename, int lineNum, char *result)
{
    FILE *fp = fopen(filename, "r");
    if (fp == NULL) 
    {
        printf("文件打开失败\n");
        return 0;
   }
    
    char buf[200];
    int currentLine = 0;
    
    // 循环读取到第N行
    while (fgets(buf, sizeof(buf), fp) != NULL) 
    {
        currentLine++;
        if (currentLine == lineNum) {
            strcpy(result, buf);
            fclose(fp);
            return 1;  // 成功
        }
    }
    
    fclose(fp);
    printf("文件只有 %d 行，没有第 %d 行\n", currentLine, lineNum);
    return 0;  // 失败
}

// 使用
int main() 
{
    char line[200];
    if (readNthLine("./data/user1.txt", 2, line)) 
    {
        printf("第2行内容：%s", line);
    }
    return 0;
}
```



##### 示例3：从链表中读取第N个元素（利用fseek跳过）

```c
// 直接跳转到链表文件的第N个数据
int readNthUser(const char *filename, int position, USER *user) {
    FILE *fp = fopen(filename, "r");
    if (fp == NULL) {
        printf("文件打开失败\n");
        return 0;
    }
    
    char buf[200];
    int currentPos = 0;
    
    // 跳过前 position-1 行
    while (currentPos < position - 1) {
        if (fgets(buf, sizeof(buf), fp) == NULL) {
            printf("文件只有 %d 条数据\n", currentPos);
            fclose(fp);
            return 0;
        }
        currentPos++;
    }
    
    // 读取第position行
    if (fgets(buf, sizeof(buf), fp) != NULL) {
        sscanf(buf, "%s %s %d", 
               user->account, user->password, &user->role);
        fclose(fp);
        return 1;
    }
    
    fclose(fp);
    return 0;
}

// 使用
int main() {
    USER user;
    if (readNthUser("./data/user1.txt", 3, &user)) {
        printf("第3个用户：%s %s %d\n", 
               user.account, user.password, user.role);
    }
    return 0;
}
```



##### 示例4：在文件末尾追加数据

```c
// 追加用户到文件末尾
void appendUser(const char *filename, USER *user) {
    FILE *fp = fopen(filename, "a");  // 追加模式
    if (fp == NULL) {
        printf("文件打开失败\n");
        return;
    }
    
    // 获取当前位置（应该在末尾）
    long pos = ftell(fp);
    printf("追加位置：%ld 字节\n", pos);
    
    // 写入数据
    fprintf(fp, "%s %s %d\n", 
            user->account, user->password, user->role);
    
    fclose(fp);
    printf("追加成功！\n");
}

// 使用
int main() {
    USER newUser = {"test", "123456", 0};
    appendUser("./data/user1.txt", &newUser);
    return 0;
}
```



##### 示例5：修改文件中的特定数据（随机读写）

```c
// 修改文件中第N个用户的密码
int updateNthUserPassword(const char *filename, int position, const char *newPassword) 
{
    FILE *fp = fopen(filename, "r+");  // 读写模式
    if (fp == NULL) 
    {
        printf("文件打开失败\n");
        return 0;
    }
    
    char buf[200];
    int currentPos = 0;
    long lineStart = 0;  // 记录行的起始位置
    
    // 找到第N行的起始位置
    while (currentPos < position - 1) 
    {
        lineStart = ftell(fp);  // 记录当前位置
        if (fgets(buf, sizeof(buf), fp) == NULL) 
        {
            printf("文件只有 %d 条数据\n", currentPos);
            fclose(fp);
            return 0;
        }
        currentPos++;
    }
    
    // 记录第N行的起始位置
    lineStart = ftell(fp);
    
    // 读取第N行
    if (fgets(buf, sizeof(buf), fp) != NULL) 
    {
        USER user;
        sscanf(buf, "%s %s %d", user.account, user.password, &user.role);
        
        // 修改密码
        strcpy(user.password, newPassword);
        
        // 回到行首
        fseek(fp, lineStart, SEEK_SET);
        
        // 写入新数据
        fprintf(fp, "%s %s %d\n", user.account, user.password, user.role);
        
        fclose(fp);
        printf("修改成功！\n");
        return 1;
    }
    
    fclose(fp);
    return 0;
}

// 使用
int main() 
{
    updateNthUserPassword("./data/user1.txt", 2, "newpass888");
    return 0;
}
```

