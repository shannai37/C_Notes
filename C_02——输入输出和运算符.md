# C_02——输入输出和运算符

## 基础概念

输入——进入内存的东西（输入设备：键盘、麦克风、摄像头...）

输出——离开内存的东西（输出设备：屏幕、打印机、3D打印机...）

![image-20250927151640746](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250927151640746.png)

在C语言中，**标准输入**通常是键盘，**标准输出**是屏幕（控制台）

Win10开始，我们调用cmd都是终端 

可以`右键——设置——默认应用程序`切换成控制台（与终端字符宽度、高度，窗口宽度、高度不同）

![image-20250927152202638](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250927152202638.png)



## 输出格式

总结：

| 说明符 | printf用途           | scanf用途                    |
| :----- | :------------------- | :--------------------------- |
| %d     | 输出有符号十进制整数 | 读取有符号十进制整数         |
| %i     | 同%d                 | 可读取十进制/八进制/十六进制 |
| %u     | 输出无符号十进制整数 | 读取无符号十进制整数         |
| %o     | 输出八进制           | 读取八进制                   |
| %x/%X  | 输出十六进制         | 读取十六进制                 |
| %f     | 输出浮点数           | 读取float                    |
| %lf    | 同%f (double)        | 读取double                   |
| %e/%E  | 科学计数法输出       | 同%f                         |
| %g/%G  | 自动选择%f或%e       | 同%f                         |
| %c     | 输出字符             | 读取字符                     |
| %s     | 输出字符串           | 读取字符串(无空格)           |
| %p     | 输出指针地址         | 无                           |
| %[]    | 无                   | 扫描字符集合                 |
| %%     | 输出%字符            | 无                           |





## printf修饰符

修饰符用来调整输出宽度、精度或者是输出数据的长度等等。

- 宽度：指定最小输出宽度。如果数据的实际宽度小于指定宽度，`printf`将用空格填充（或其他填充，见下文）以满足宽度要求。例如，`%5d`表示输出的整数至少占5个字符宽度。

- 精度：

  整数：如果整数的位数少于指定的精度，结果将在前面填充`0`以达到指定的位数。

  浮点数：例如，`%.2f`表示浮点数输出时保留两位小数。如果小数本身位数不够，则在后面补`0`

- 左对齐：默认情况下，输出是右对齐的，如果你想要左对齐输出，可以在宽度前加`-`修饰符，例如`%-5d`。

- 显示正号：使用`+`修饰符会在正数前面显示加号，例如`%+d`。

- 空格：如果输出值为正数，`  `（空格）修饰符会在值前面添加一个空格，为负数则不影响，这对齐输出有帮助，例如`% d`。

- `#`：对不同类型的输出有不同的影响。例如，对于八进制数前加`0`，十六进制数前加`0x`或`0X`，对于`%g`或`%G`保留小数点后的零。

- 长度修饰符：指定整数或浮点数的大小或长度。例如，`%ld`用于`long int`类型，`%llu`用于`unsigned long long int`类型

```c
#include <stdio.h>
#include <stdlib.h>


void test1(int m,int n)
{
	printf("%9d\n", 123);    // 右对齐，至少9个字符宽
    printf("%09d\n", 123);    // 右对齐，至少9个字符宽，不够补0 
    printf("%-9d\n", 123);   // 左对齐，至少9个字符宽
    printf("%.5d\n", 123);   // 至少5位数字，不足前面补0
    printf("%+d\n", 123);    // 显示正号
    printf("% d\n", 123);    // 正数前空格
    printf("%x\n", 255);     // 十六进制小写
    printf("%#x\n", 255);    // 十六进制小写，0x前缀
    printf("%p\n",&m); 	//输出指针地址 
    printf("%.3f\n", 3.14159); // 浮点数，保留3位小数
    printf("%.7f\n", 3.14159); // 浮点数，保留7位小数，不足后面补0 
    printf("%6.2f\n", 3.14159); // 至少6个字符宽，保留2位小数
    printf("%*.*f\n", m, n, 3.14159); // 使用参数指定宽度和精度

} 
int main(int argc, char *argv[]) {
	test1(6,2);
	return 0;
}
```

![image-20250927162927498](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250927162927498.png)

## 转义字符

![image-20250927153233371](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250927153233371.png)

请注意：回车、换行在windows操作可能相同，但不代表其他操作系统操作也一样。



#### 输入输出缓冲区

![image-20250927164601973](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250927164601973.png)



## getchar() 与 putchar() 

### 函数原型

```C
int getchar(void);
//无参数：不需要任何参数
//缓冲输入：通常使用行缓冲，需要按回车键后才会处理输入
```

**功能**

从标准输入（通常是键盘）读取一个字符。

**返回值**

- 成功：返回读取的字符（转换为 `unsigned char` 类型，然后转换为 `int`）
- 失败或到达文件末尾：返回 `EOF`（通常为 -1）



```c
int putchar(int c);
```

**功能**

向标准输出（通常是屏幕）输出一个字符。

**参数**

- `c`：要输出的字符（以 `int` 形式传递）

**返回值**

- 成功：返回输出的字符
- 失败：返回 `EOF`



### 工作原理

`getchar` 和 `putchar` 的行为与 “输入 / 输出缓冲区” 密切相关。缓冲区是内存中的一块区域，用于暂存输入 / 输出的数据，减少直接读写硬件的次数（硬件速度比内存慢很多）。

#### **输入缓冲区：getchar 如何读取字符？**

当你在键盘输入字符时，字符不会直接被 `getchar` 读取，而是先存入**输入缓冲区**。只有当以下情况发生时，`getchar` 才会从缓冲区取字符：

- 用户按下回车键（`'\n'`），输入结束；
- 缓冲区已满（比如输入的字符数达到系统设定的上限）；
- 程序主动刷新缓冲区（如使用 `fflush(stdin)`，但不推荐，可能导致不可移植性）



**示例：输入多个字符时的流程**

```c
#include <stdio.h>
 
int main() {
    char c1, c2, c3;
    c1 = getchar();  // 第1次调用 getchar
    c2 = getchar();  // 第2次调用 getchar
    c3 = getchar();  // 第3次调用 getchar
    putchar(c1);
    putchar(c2);
    putchar(c3);
    return 0;
}
```



运行时：

1. 程序等待输入，你输入 `abc` 并按回车（输入内容为 `a b c \n`）。
2. 输入缓冲区存储了 `a`, `b`, `c`, `\n`。
3. 第 1 次 `getchar` 取 `a`，第 2 次取 `b`，第 3 次取 `c`。
4. `putchar` 依次输出 `a`, `b`, `c`（屏幕显示 `abc`）。



#### **输出缓冲区：putchar 如何显示字符？**

`putchar` 写入的字符会先存入**输出缓冲区**，当以下情况发生时，缓冲区内容会被 “刷新”（写入屏幕）：

- 缓冲区已满；
- 遇到换行符 `'\n'`（如 `putchar('\n')`）；
- 程序正常结束（自动刷新）；
- 主动调用 `fflush(stdout)` 刷新输出缓冲区。

```c
#include <stdio.h>
#include <unistd.h>  // 用于 sleep 函数
 
int main() {
    putchar('A');  // 写入输出缓冲区，但未刷新
    sleep(3);      // 暂停3秒（此时屏幕不会显示'A'）
    putchar('\n'); // 遇到换行符，刷新缓冲区，屏幕显示'A'并换行
    return 0;
}
```

运行时，前 3 秒屏幕不会显示 `A`，直到 `putchar('\n')` 刷新缓冲区，才会显示 `A` 并换行



#### ！！！scanf() getchar()区别：

相同：

识别enter 做为结束输入

不同：
getchar严格只接受一个字符（1个字节），但不知道是什么数据

| 特性         | scanf()                  | getchar()             |
| :----------- | :----------------------- | :-------------------- |
| 功能         | 格式化输入，可读多种类型 | 只能读字符            |
| 空白字符处理 | 根据格式字符串可能跳过   | 不跳过，读取所有字符  |
| 返回值       | 成功读取的数据项数       | 读取的字符（int类型） |
| 使用复杂度   | 相对复杂，需指定格式     | 简单                  |
| 适用场景     | 格式化输入               | 字符级输入            |



## getch()与putch()

### 函数原型：

```C
#include <conio.h>  
int getch(void);
```

### 特点：

1. **无缓冲输入**：立即读取字符，不需要按回车键
2. **无回显**：输入的字符不会显示在屏幕上
3. **Windows特有**：主要在Windows平台的编译器中可用
4. **直接读取**：直接从键盘读取，不经过标准输入流

### getch()与scanf()、getchar()不同点:

**getch()不需要enter，直接点击键盘就能在输出设备获取键盘对应的键位值（如字符等）**

作用1：可以仿照密码输入（密文输入）

```C
ch = getch();
putchar('*');
```

putch() ：向屏幕输出单个字符

```c
#include <conio.h>  // putch() 需要这个头文件

int main() {
    putch('A');      // 输出字符 A
    putch('\n');     // 输出换行符
    putch(65);       // 输出 ASCII 码 65 对应的字符 A
    
    return 0;
}
```

- `putch()` 不是标准C库函数，在一些编译器中可能不可用
- 在标准C中，可以使用 `putchar()` 作为替代



## getchar()使用例子

用户名和密码的输入：

用户名只能输入字母，并且最多12位；按回车结束输入

密码只能输入数字，并且最多8位，按回车结束输入

**注意体会getchar()使用的时机、清理缓冲区等操作**

```c
void module9()//用户名和密码的输入
{
	char str[13],num[9],ch;
	int user = 0,pw = 0;
	printf("请输入用户名,最大长度为12位:");
	while(user < 12) //限制用户名长度为12位 
	{
		ch = getchar();
		if(ch == '\n') break;
		if(isalpha(ch)) //如果是字母,才会纪录 
		{
			str[user++] = ch;
		}
	}
	//清理缓冲区，为下次读取做准备 
	while ((ch = getchar()) != '\n' && ch != EOF);
	
	printf("请输入密码,最大长度为8位:");
	while(pw < 8)
	{
		ch = getchar();
		if(ch == '\n') break;
		if(isdigit(ch))
		{
			num[pw++] = ch;
		}
	}
	// 清除缓冲区 
    while ((ch = getchar()) != '\n' && ch != EOF);
	//输出 
	int i;
	printf("您的用户名是:");
	for(i = 0 ; i < user ; i++)
	{
		printf("%c",str[i]);
	}
	printf("\n");
	printf("您的密码是:");
	for(i = 0 ; i < pw ; i++)
	{
		printf("%c",num[i]);
	}
	printf("\n");
} 
```

### `isdigit(c)` 为什么能检测 char 类型？

首先简单讲一下两个函数：

```C
/*
isdigit() 函数
功能
判断一个字符是否为数字字符（0-9）
返回值
非零值：如果字符是数字（'0'~'9'）
0：如果字符不是数字
*/
#include <ctype.h>
int isdigit(int c);
```

```C
/*
isalpha() 函数
功能
判断一个字符是否为字母字符（a-z 或 A-Z）
返回值
非零值：如果字符是字母（'a'~'z' 或 'A'~'Z'）
0：如果字符不是字母
*/
#include <ctype.h>
int isalpha(int c);
```

**它们接受 `int` 参数但完全可以处理 `char` 类型**

为什么能处理呢？

- `char` 本质上是一个**1字节的整数类型**
- 字符在内存中存储的是其**ASCII码值**（整数）
- `'A'` 实际上就是整数 `65`，`'0'` 就是整数 `48`

```C
#include <ctype.h>

char c = 'A';
// 调用 isalpha(c) 时发生：
// 1. 'A' 被转换成 int 类型 （65）
// 2. 转换后的值传递给 isalpha()
// 3. isalpha() 检查这个整数值对应的ASCII字符
```

```c
char c = '7';
    
    // 实际上发生的过程：
    // 1. c ('7') 被转换成int类型 55 
    // 2. isdigit(55) 检查 55 是否在 '0'~'9' 的范围内(48-57)
    // 3. 返回非零值（真）
    
    if (isdigit(c)) {  // c 被自动提升为 int
        printf("'%c' 是数字\n", c);
    }
```

### 为什么 `isdigit()`、`isalpha()` 使用 int 参数

设计原因：

1. **可以正确处理 EOF**：

   - EOF 通常定义为 -1
   - `char` 类型可能无法正确表示 -1（特别是无符号 char）
   - `int` 可以明确区分字符和文件结束标志

   

   

   **"int 可以明确区分字符和文件结束标志"** 的含义是:

![image-20251001214243313](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20251001214243313.png)